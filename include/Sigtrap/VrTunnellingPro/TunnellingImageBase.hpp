// Autogenerated from CppHeaderCreator
// Created by Sc2ad
// =========================================================================
#pragma once
// Begin includes
#include "beatsaber-hook/shared/utils/typedefs.h"
#include "beatsaber-hook/shared/utils/byref.hpp"
// Including type: Sigtrap.VrTunnellingPro.TunnellingBase
#include "Sigtrap/VrTunnellingPro/TunnellingBase.hpp"
// Including type: Sigtrap.VrTunnellingPro.TunnellingBase/Sigtrap.VrTunnellingPro.BackgroundMode
#include "Sigtrap/VrTunnellingPro/TunnellingBase_BackgroundMode.hpp"
// Including type: Sigtrap.VrTunnellingPro.TunnellingBase/Sigtrap.VrTunnellingPro.MSAA
#include "Sigtrap/VrTunnellingPro/TunnellingBase_MSAA.hpp"
// Including type: Sigtrap.VrTunnellingPro.TunnellingBase/Sigtrap.VrTunnellingPro.MaskMode
#include "Sigtrap/VrTunnellingPro/TunnellingBase_MaskMode.hpp"
// Including type: UnityEngine.Vector4
#include "UnityEngine/Vector4.hpp"
#include "beatsaber-hook/shared/utils/il2cpp-utils-methods.hpp"
#include "beatsaber-hook/shared/utils/il2cpp-utils-properties.hpp"
#include "beatsaber-hook/shared/utils/il2cpp-utils-fields.hpp"
#include "beatsaber-hook/shared/utils/utils.h"
#include "beatsaber-hook/shared/utils/typedefs-array.hpp"
#include "beatsaber-hook/shared/utils/typedefs-string.hpp"
// Completed includes
// Begin forward declares
// Forward declaring namespace: UnityEngine
namespace UnityEngine {
  // Forward declaring type: Material
  class Material;
  // Forward declaring type: GameObject
  class GameObject;
  // Forward declaring type: Mesh
  class Mesh;
  // Forward declaring type: MeshRenderer
  class MeshRenderer;
  // Forward declaring type: MeshFilter
  class MeshFilter;
  // Forward declaring type: Renderer
  class Renderer;
  // Forward declaring type: RenderTexture
  class RenderTexture;
  // Skipping declaration: Quaternion because it is already included!
}
// Forward declaring namespace: UnityEngine::Rendering
namespace UnityEngine::Rendering {
  // Forward declaring type: CommandBuffer
  class CommandBuffer;
  // Forward declaring type: CameraEvent
  struct CameraEvent;
}
// Forward declaring namespace: System::Collections::Generic
namespace System::Collections::Generic {
  // Forward declaring type: List`1<T>
  template<typename T>
  class List_1;
}
// Forward declaring namespace: System
namespace System {
  // Forward declaring type: String
  class String;
}
// Forward declaring namespace: Sigtrap::VrTunnellingPro
namespace Sigtrap::VrTunnellingPro {
  // Forward declaring type: TunnellingPreset
  class TunnellingPreset;
}
// Completed forward declares
// Type namespace: Sigtrap.VrTunnellingPro
namespace Sigtrap::VrTunnellingPro {
  // Forward declaring type: TunnellingImageBase
  class TunnellingImageBase;
}
#include "beatsaber-hook/shared/utils/il2cpp-type-check.hpp"
NEED_NO_BOX(::Sigtrap::VrTunnellingPro::TunnellingImageBase);
DEFINE_IL2CPP_ARG_TYPE(::Sigtrap::VrTunnellingPro::TunnellingImageBase*, "Sigtrap.VrTunnellingPro", "TunnellingImageBase");
// Type namespace: Sigtrap.VrTunnellingPro
namespace Sigtrap::VrTunnellingPro {
  // Size: 0x338
  #pragma pack(push, 1)
  // Autogenerated type: Sigtrap.VrTunnellingPro.TunnellingImageBase
  // [TokenAttribute] Offset: FFFFFFFF
  class TunnellingImageBase : public ::Sigtrap::VrTunnellingPro::TunnellingBase {
    public:
    // Nested type: ::Sigtrap::VrTunnellingPro::TunnellingImageBase::BlurKernel
    struct BlurKernel;
    // Nested type: ::Sigtrap::VrTunnellingPro::TunnellingImageBase::CounterVelocityMode
    struct CounterVelocityMode;
    // Size: 0x4
    #pragma pack(push, 1)
    // Autogenerated type: Sigtrap.VrTunnellingPro.TunnellingImageBase/Sigtrap.VrTunnellingPro.BlurKernel
    // [TokenAttribute] Offset: FFFFFFFF
    struct BlurKernel/*, public ::System::Enum*/ {
      public:
      public:
      // public System.Int32 value__
      // Size: 0x4
      // Offset: 0x0
      int value;
      // Field size check
      static_assert(sizeof(int) == 0x4);
      public:
      // Creating value type constructor for type: BlurKernel
      constexpr BlurKernel(int value_ = {}) noexcept : value{value_} {}
      // Creating interface conversion operator: operator ::System::Enum
      operator ::System::Enum() noexcept {
        return *reinterpret_cast<::System::Enum*>(this);
      }
      // Creating conversion operator: operator int
      constexpr operator int() const noexcept {
        return value;
      }
      // static field const value: static public Sigtrap.VrTunnellingPro.TunnellingImageBase/Sigtrap.VrTunnellingPro.BlurKernel FIVE
      static constexpr const int FIVE = 0;
      // Get static field: static public Sigtrap.VrTunnellingPro.TunnellingImageBase/Sigtrap.VrTunnellingPro.BlurKernel FIVE
      static ::Sigtrap::VrTunnellingPro::TunnellingImageBase::BlurKernel _get_FIVE();
      // Set static field: static public Sigtrap.VrTunnellingPro.TunnellingImageBase/Sigtrap.VrTunnellingPro.BlurKernel FIVE
      static void _set_FIVE(::Sigtrap::VrTunnellingPro::TunnellingImageBase::BlurKernel value);
      // static field const value: static public Sigtrap.VrTunnellingPro.TunnellingImageBase/Sigtrap.VrTunnellingPro.BlurKernel NINE
      static constexpr const int NINE = 1;
      // Get static field: static public Sigtrap.VrTunnellingPro.TunnellingImageBase/Sigtrap.VrTunnellingPro.BlurKernel NINE
      static ::Sigtrap::VrTunnellingPro::TunnellingImageBase::BlurKernel _get_NINE();
      // Set static field: static public Sigtrap.VrTunnellingPro.TunnellingImageBase/Sigtrap.VrTunnellingPro.BlurKernel NINE
      static void _set_NINE(::Sigtrap::VrTunnellingPro::TunnellingImageBase::BlurKernel value);
      // static field const value: static public Sigtrap.VrTunnellingPro.TunnellingImageBase/Sigtrap.VrTunnellingPro.BlurKernel THIRTEEN
      static constexpr const int THIRTEEN = 2;
      // Get static field: static public Sigtrap.VrTunnellingPro.TunnellingImageBase/Sigtrap.VrTunnellingPro.BlurKernel THIRTEEN
      static ::Sigtrap::VrTunnellingPro::TunnellingImageBase::BlurKernel _get_THIRTEEN();
      // Set static field: static public Sigtrap.VrTunnellingPro.TunnellingImageBase/Sigtrap.VrTunnellingPro.BlurKernel THIRTEEN
      static void _set_THIRTEEN(::Sigtrap::VrTunnellingPro::TunnellingImageBase::BlurKernel value);
      // Get instance field reference: public System.Int32 value__
      int& dyn_value__();
    }; // Sigtrap.VrTunnellingPro.TunnellingImageBase/Sigtrap.VrTunnellingPro.BlurKernel
    #pragma pack(pop)
    static check_size<sizeof(TunnellingImageBase::BlurKernel), 0 + sizeof(int)> __Sigtrap_VrTunnellingPro_TunnellingImageBase_BlurKernelSizeCheck;
    static_assert(sizeof(TunnellingImageBase::BlurKernel) == 0x4);
    // Size: 0x4
    #pragma pack(push, 1)
    // Autogenerated type: Sigtrap.VrTunnellingPro.TunnellingImageBase/Sigtrap.VrTunnellingPro.CounterVelocityMode
    // [TokenAttribute] Offset: FFFFFFFF
    struct CounterVelocityMode/*, public ::System::Enum*/ {
      public:
      public:
      // public System.Int32 value__
      // Size: 0x4
      // Offset: 0x0
      int value;
      // Field size check
      static_assert(sizeof(int) == 0x4);
      public:
      // Creating value type constructor for type: CounterVelocityMode
      constexpr CounterVelocityMode(int value_ = {}) noexcept : value{value_} {}
      // Creating interface conversion operator: operator ::System::Enum
      operator ::System::Enum() noexcept {
        return *reinterpret_cast<::System::Enum*>(this);
      }
      // Creating conversion operator: operator int
      constexpr operator int() const noexcept {
        return value;
      }
      // static field const value: static public Sigtrap.VrTunnellingPro.TunnellingImageBase/Sigtrap.VrTunnellingPro.CounterVelocityMode OFF
      static constexpr const int OFF = 0;
      // Get static field: static public Sigtrap.VrTunnellingPro.TunnellingImageBase/Sigtrap.VrTunnellingPro.CounterVelocityMode OFF
      static ::Sigtrap::VrTunnellingPro::TunnellingImageBase::CounterVelocityMode _get_OFF();
      // Set static field: static public Sigtrap.VrTunnellingPro.TunnellingImageBase/Sigtrap.VrTunnellingPro.CounterVelocityMode OFF
      static void _set_OFF(::Sigtrap::VrTunnellingPro::TunnellingImageBase::CounterVelocityMode value);
      // static field const value: static public Sigtrap.VrTunnellingPro.TunnellingImageBase/Sigtrap.VrTunnellingPro.CounterVelocityMode SHADER
      static constexpr const int SHADER = 1;
      // Get static field: static public Sigtrap.VrTunnellingPro.TunnellingImageBase/Sigtrap.VrTunnellingPro.CounterVelocityMode SHADER
      static ::Sigtrap::VrTunnellingPro::TunnellingImageBase::CounterVelocityMode _get_SHADER();
      // Set static field: static public Sigtrap.VrTunnellingPro.TunnellingImageBase/Sigtrap.VrTunnellingPro.CounterVelocityMode SHADER
      static void _set_SHADER(::Sigtrap::VrTunnellingPro::TunnellingImageBase::CounterVelocityMode value);
      // static field const value: static public Sigtrap.VrTunnellingPro.TunnellingImageBase/Sigtrap.VrTunnellingPro.CounterVelocityMode REAL
      static constexpr const int REAL = 2;
      // Get static field: static public Sigtrap.VrTunnellingPro.TunnellingImageBase/Sigtrap.VrTunnellingPro.CounterVelocityMode REAL
      static ::Sigtrap::VrTunnellingPro::TunnellingImageBase::CounterVelocityMode _get_REAL();
      // Set static field: static public Sigtrap.VrTunnellingPro.TunnellingImageBase/Sigtrap.VrTunnellingPro.CounterVelocityMode REAL
      static void _set_REAL(::Sigtrap::VrTunnellingPro::TunnellingImageBase::CounterVelocityMode value);
      // Get instance field reference: public System.Int32 value__
      int& dyn_value__();
    }; // Sigtrap.VrTunnellingPro.TunnellingImageBase/Sigtrap.VrTunnellingPro.CounterVelocityMode
    #pragma pack(pop)
    static check_size<sizeof(TunnellingImageBase::CounterVelocityMode), 0 + sizeof(int)> __Sigtrap_VrTunnellingPro_TunnellingImageBase_CounterVelocityModeSizeCheck;
    static_assert(sizeof(TunnellingImageBase::CounterVelocityMode) == 0x4);
    #ifdef USE_CODEGEN_FIELDS
    public:
    #else
    #ifdef CODEGEN_FIELD_ACCESSIBILITY
    CODEGEN_FIELD_ACCESSIBILITY:
    #else
    protected:
    #endif
    #endif
    // [TooltipAttribute] Offset: 0x72AEE0
    // public Sigtrap.VrTunnellingPro.TunnellingBase/Sigtrap.VrTunnellingPro.BackgroundMode backgroundMode
    // Size: 0x4
    // Offset: 0x1C8
    ::Sigtrap::VrTunnellingPro::TunnellingBase::BackgroundMode backgroundMode;
    // Field size check
    static_assert(sizeof(::Sigtrap::VrTunnellingPro::TunnellingBase::BackgroundMode) == 0x4);
    // [RangeAttribute] Offset: 0x72AF18
    // [TooltipAttribute] Offset: 0x72AF18
    // public System.Single effectOverlay
    // Size: 0x4
    // Offset: 0x1CC
    float effectOverlay;
    // Field size check
    static_assert(sizeof(float) == 0x4);
    // [TooltipAttribute] Offset: 0x72AF6C
    // private UnityEngine.GameObject _cageParent
    // Size: 0x8
    // Offset: 0x1D0
    ::UnityEngine::GameObject* cageParent;
    // Field size check
    static_assert(sizeof(::UnityEngine::GameObject*) == 0x8);
    // [RangeAttribute] Offset: 0x72AFB8
    // public System.Int32 cageDownsample
    // Size: 0x4
    // Offset: 0x1D8
    int cageDownsample;
    // Field size check
    static_assert(sizeof(int) == 0x4);
    // public Sigtrap.VrTunnellingPro.TunnellingBase/Sigtrap.VrTunnellingPro.MSAA cageAntiAliasing
    // Size: 0x4
    // Offset: 0x1DC
    ::Sigtrap::VrTunnellingPro::TunnellingBase::MSAA cageAntiAliasing;
    // Field size check
    static_assert(sizeof(::Sigtrap::VrTunnellingPro::TunnellingBase::MSAA) == 0x4);
    // public System.Boolean cageUpdateEveryFrame
    // Size: 0x1
    // Offset: 0x1E0
    bool cageUpdateEveryFrame;
    // Field size check
    static_assert(sizeof(bool) == 0x1);
    // Padding between fields: cageUpdateEveryFrame and: cageFogDensity
    char __padding5[0x3] = {};
    // [RangeAttribute] Offset: 0x72AFD0
    // public System.Single cageFogDensity
    // Size: 0x4
    // Offset: 0x1E4
    float cageFogDensity;
    // Field size check
    static_assert(sizeof(float) == 0x4);
    // [RangeAttribute] Offset: 0x72AFF0
    // public System.Single cageFogPower
    // Size: 0x4
    // Offset: 0x1E8
    float cageFogPower;
    // Field size check
    static_assert(sizeof(float) == 0x4);
    // [RangeAttribute] Offset: 0x72B008
    // public System.Single cageFogBlend
    // Size: 0x4
    // Offset: 0x1EC
    float cageFogBlend;
    // Field size check
    static_assert(sizeof(float) == 0x4);
    // public Sigtrap.VrTunnellingPro.TunnellingBase/Sigtrap.VrTunnellingPro.MaskMode maskMode
    // Size: 0x4
    // Offset: 0x1F0
    ::Sigtrap::VrTunnellingPro::TunnellingBase::MaskMode maskMode;
    // Field size check
    static_assert(sizeof(::Sigtrap::VrTunnellingPro::TunnellingBase::MaskMode) == 0x4);
    // [RangeAttribute] Offset: 0x72B020
    // public System.Int32 blurDownsample
    // Size: 0x4
    // Offset: 0x1F4
    int blurDownsample;
    // Field size check
    static_assert(sizeof(int) == 0x4);
    // [RangeAttribute] Offset: 0x72B038
    // public System.Single blurDistance
    // Size: 0x4
    // Offset: 0x1F8
    float blurDistance;
    // Field size check
    static_assert(sizeof(float) == 0x4);
    // [RangeAttribute] Offset: 0x72B050
    // public System.Int32 blurPasses
    // Size: 0x4
    // Offset: 0x1FC
    int blurPasses;
    // Field size check
    static_assert(sizeof(int) == 0x4);
    // public Sigtrap.VrTunnellingPro.TunnellingImageBase/Sigtrap.VrTunnellingPro.BlurKernel blurSamples
    // Size: 0x4
    // Offset: 0x200
    ::Sigtrap::VrTunnellingPro::TunnellingImageBase::BlurKernel blurSamples;
    // Field size check
    static_assert(sizeof(::Sigtrap::VrTunnellingPro::TunnellingImageBase::BlurKernel) == 0x4);
    // [TooltipAttribute] Offset: 0x72B068
    // public System.Boolean irisZRejection
    // Size: 0x1
    // Offset: 0x204
    bool irisZRejection;
    // Field size check
    static_assert(sizeof(bool) == 0x1);
    // Padding between fields: irisZRejection and: counterVelocityMode
    char __padding14[0x3] = {};
    // public Sigtrap.VrTunnellingPro.TunnellingImageBase/Sigtrap.VrTunnellingPro.CounterVelocityMode counterVelocityMode
    // Size: 0x4
    // Offset: 0x208
    ::Sigtrap::VrTunnellingPro::TunnellingImageBase::CounterVelocityMode counterVelocityMode;
    // Field size check
    static_assert(sizeof(::Sigtrap::VrTunnellingPro::TunnellingImageBase::CounterVelocityMode) == 0x4);
    // [TooltipAttribute] Offset: 0x72B0A0
    // public System.Single counterVelocityResetDistance
    // Size: 0x4
    // Offset: 0x20C
    float counterVelocityResetDistance;
    // Field size check
    static_assert(sizeof(float) == 0x4);
    // [TooltipAttribute] Offset: 0x72B0D8
    // public System.Single counterVelocityResetTime
    // Size: 0x4
    // Offset: 0x210
    float counterVelocityResetTime;
    // Field size check
    static_assert(sizeof(float) == 0x4);
    // [RangeAttribute] Offset: 0x72B110
    // [TooltipAttribute] Offset: 0x72B110
    // public System.Single counterVelocityStrength
    // Size: 0x4
    // Offset: 0x214
    float counterVelocityStrength;
    // Field size check
    static_assert(sizeof(float) == 0x4);
    // [TooltipAttribute] Offset: 0x72B164
    // public UnityEngine.Vector3 counterVelocityPerAxis
    // Size: 0xC
    // Offset: 0x218
    ::UnityEngine::Vector3 counterVelocityPerAxis;
    // Field size check
    static_assert(sizeof(::UnityEngine::Vector3) == 0xC);
    // Padding between fields: counterVelocityPerAxis and: maskCmd
    char __padding19[0x4] = {};
    // private UnityEngine.Rendering.CommandBuffer _maskCmd
    // Size: 0x8
    // Offset: 0x228
    ::UnityEngine::Rendering::CommandBuffer* maskCmd;
    // Field size check
    static_assert(sizeof(::UnityEngine::Rendering::CommandBuffer*) == 0x8);
    // private UnityEngine.Material _matTunnel
    // Size: 0x8
    // Offset: 0x230
    ::UnityEngine::Material* matTunnel;
    // Field size check
    static_assert(sizeof(::UnityEngine::Material*) == 0x8);
    // private UnityEngine.Material _matMask
    // Size: 0x8
    // Offset: 0x238
    ::UnityEngine::Material* matMask;
    // Field size check
    static_assert(sizeof(::UnityEngine::Material*) == 0x8);
    // private UnityEngine.Material _matWindow
    // Size: 0x8
    // Offset: 0x240
    ::UnityEngine::Material* matWindow;
    // Field size check
    static_assert(sizeof(::UnityEngine::Material*) == 0x8);
    // private UnityEngine.Material _matCopyAlpha
    // Size: 0x8
    // Offset: 0x248
    ::UnityEngine::Material* matCopyAlpha;
    // Field size check
    static_assert(sizeof(::UnityEngine::Material*) == 0x8);
    // private UnityEngine.Material _matBlur
    // Size: 0x8
    // Offset: 0x250
    ::UnityEngine::Material* matBlur;
    // Field size check
    static_assert(sizeof(::UnityEngine::Material*) == 0x8);
    // private UnityEngine.Material _matSkysphere
    // Size: 0x8
    // Offset: 0x258
    ::UnityEngine::Material* matSkysphere;
    // Field size check
    static_assert(sizeof(::UnityEngine::Material*) == 0x8);
    // private UnityEngine.Mesh _meshSkysphere
    // Size: 0x8
    // Offset: 0x260
    ::UnityEngine::Mesh* meshSkysphere;
    // Field size check
    static_assert(sizeof(::UnityEngine::Mesh*) == 0x8);
    // private UnityEngine.MeshRenderer[] _cageMrs
    // Size: 0x8
    // Offset: 0x268
    ::ArrayW<::UnityEngine::MeshRenderer*> cageMrs;
    // Field size check
    static_assert(sizeof(::ArrayW<::UnityEngine::MeshRenderer*>) == 0x8);
    // private System.Collections.Generic.List`1<UnityEngine.MeshFilter> _cageMfs
    // Size: 0x8
    // Offset: 0x270
    ::System::Collections::Generic::List_1<::UnityEngine::MeshFilter*>* cageMfs;
    // Field size check
    static_assert(sizeof(::System::Collections::Generic::List_1<::UnityEngine::MeshFilter*>*) == 0x8);
    // private System.Collections.Generic.List`1<UnityEngine.Renderer> _maskObjects
    // Size: 0x8
    // Offset: 0x278
    ::System::Collections::Generic::List_1<::UnityEngine::Renderer*>* maskObjects;
    // Field size check
    static_assert(sizeof(::System::Collections::Generic::List_1<::UnityEngine::Renderer*>*) == 0x8);
    // private UnityEngine.RenderTexture _cageRt
    // Size: 0x8
    // Offset: 0x280
    ::UnityEngine::RenderTexture* cageRt;
    // Field size check
    static_assert(sizeof(::UnityEngine::RenderTexture*) == 0x8);
    // private UnityEngine.RenderTexture _maskRt
    // Size: 0x8
    // Offset: 0x288
    ::UnityEngine::RenderTexture* maskRt;
    // Field size check
    static_assert(sizeof(::UnityEngine::RenderTexture*) == 0x8);
    // private UnityEngine.RenderTexture _blurRt0
    // Size: 0x8
    // Offset: 0x290
    ::UnityEngine::RenderTexture* blurRt0;
    // Field size check
    static_assert(sizeof(::UnityEngine::RenderTexture*) == 0x8);
    // private UnityEngine.RenderTexture _blurRt1
    // Size: 0x8
    // Offset: 0x298
    ::UnityEngine::RenderTexture* blurRt1;
    // Field size check
    static_assert(sizeof(::UnityEngine::RenderTexture*) == 0x8);
    // private System.Int32 _rtX
    // Size: 0x4
    // Offset: 0x2A0
    int rtX;
    // Field size check
    static_assert(sizeof(int) == 0x4);
    // private System.Int32 _rtY
    // Size: 0x4
    // Offset: 0x2A4
    int rtY;
    // Field size check
    static_assert(sizeof(int) == 0x4);
    // private System.Int32 _rtA
    // Size: 0x4
    // Offset: 0x2A8
    int rtA;
    // Field size check
    static_assert(sizeof(int) == 0x4);
    // Padding between fields: rtA and: irisCmd
    char __padding37[0x4] = {};
    // private UnityEngine.Rendering.CommandBuffer _irisCmd
    // Size: 0x8
    // Offset: 0x2B0
    ::UnityEngine::Rendering::CommandBuffer* irisCmd;
    // Field size check
    static_assert(sizeof(::UnityEngine::Rendering::CommandBuffer*) == 0x8);
    // private UnityEngine.Material _matIris
    // Size: 0x8
    // Offset: 0x2B8
    ::UnityEngine::Material* matIris;
    // Field size check
    static_assert(sizeof(::UnityEngine::Material*) == 0x8);
    // private UnityEngine.Mesh _meshIris
    // Size: 0x8
    // Offset: 0x2C0
    ::UnityEngine::Mesh* meshIris;
    // Field size check
    static_assert(sizeof(::UnityEngine::Mesh*) == 0x8);
    // private UnityEngine.Vector4[] _blurOffsets
    // Size: 0x8
    // Offset: 0x2C8
    ::ArrayW<::UnityEngine::Vector4> blurOffsets;
    // Field size check
    static_assert(sizeof(::ArrayW<::UnityEngine::Vector4>) == 0x8);
    // private Sigtrap.VrTunnellingPro.TunnellingBase/Sigtrap.VrTunnellingPro.MaskMode _lastMaskMode
    // Size: 0x4
    // Offset: 0x2D0
    ::Sigtrap::VrTunnellingPro::TunnellingBase::MaskMode lastMaskMode;
    // Field size check
    static_assert(sizeof(::Sigtrap::VrTunnellingPro::TunnellingBase::MaskMode) == 0x4);
    // private Sigtrap.VrTunnellingPro.TunnellingBase/Sigtrap.VrTunnellingPro.MSAA _lastCageMsaa
    // Size: 0x4
    // Offset: 0x2D4
    ::Sigtrap::VrTunnellingPro::TunnellingBase::MSAA lastCageMsaa;
    // Field size check
    static_assert(sizeof(::Sigtrap::VrTunnellingPro::TunnellingBase::MSAA) == 0x4);
    // private System.Boolean _camHasMaskBuffer
    // Size: 0x1
    // Offset: 0x2D8
    bool camHasMaskBuffer;
    // Field size check
    static_assert(sizeof(bool) == 0x1);
    // Padding between fields: camHasMaskBuffer and: lastCageDownsample
    char __padding44[0x3] = {};
    // private System.Int32 _lastCageDownsample
    // Size: 0x4
    // Offset: 0x2DC
    int lastCageDownsample;
    // Field size check
    static_assert(sizeof(int) == 0x4);
    // private System.Int32 _lastBlurDownsample
    // Size: 0x4
    // Offset: 0x2E0
    int lastBlurDownsample;
    // Field size check
    static_assert(sizeof(int) == 0x4);
    // private System.Single _lastBlurRadius
    // Size: 0x4
    // Offset: 0x2E4
    float lastBlurRadius;
    // Field size check
    static_assert(sizeof(float) == 0x4);
    // private Sigtrap.VrTunnellingPro.TunnellingImageBase/Sigtrap.VrTunnellingPro.BlurKernel _lastBlurKernel
    // Size: 0x4
    // Offset: 0x2E8
    ::Sigtrap::VrTunnellingPro::TunnellingImageBase::BlurKernel lastBlurKernel;
    // Field size check
    static_assert(sizeof(::Sigtrap::VrTunnellingPro::TunnellingImageBase::BlurKernel) == 0x4);
    // private System.Boolean _wasDrawingIrisEarly
    // Size: 0x1
    // Offset: 0x2EC
    bool wasDrawingIrisEarly;
    // Field size check
    static_assert(sizeof(bool) == 0x1);
    // private System.Boolean _camHasIrisBuffer
    // Size: 0x1
    // Offset: 0x2ED
    bool camHasIrisBuffer;
    // Field size check
    static_assert(sizeof(bool) == 0x1);
    // Padding between fields: camHasIrisBuffer and: lastCvMode
    char __padding50[0x2] = {};
    // private Sigtrap.VrTunnellingPro.TunnellingImageBase/Sigtrap.VrTunnellingPro.CounterVelocityMode _lastCvMode
    // Size: 0x4
    // Offset: 0x2F0
    ::Sigtrap::VrTunnellingPro::TunnellingImageBase::CounterVelocityMode lastCvMode;
    // Field size check
    static_assert(sizeof(::Sigtrap::VrTunnellingPro::TunnellingImageBase::CounterVelocityMode) == 0x4);
    // private UnityEngine.Vector3 _cmPos
    // Size: 0xC
    // Offset: 0x2F4
    ::UnityEngine::Vector3 cmPos;
    // Field size check
    static_assert(sizeof(::UnityEngine::Vector3) == 0xC);
    // private UnityEngine.Vector3 _cageInitialPosLocal
    // Size: 0xC
    // Offset: 0x300
    ::UnityEngine::Vector3 cageInitialPosLocal;
    // Field size check
    static_assert(sizeof(::UnityEngine::Vector3) == 0xC);
    // private System.Single _timeToResetCounterVelocity
    // Size: 0x4
    // Offset: 0x30C
    float timeToResetCounterVelocity;
    // Field size check
    static_assert(sizeof(float) == 0x4);
    // private System.Int32 _propColor
    // Size: 0x4
    // Offset: 0x310
    int propColor;
    // Field size check
    static_assert(sizeof(int) == 0x4);
    // private System.Int32 _propBkgRt
    // Size: 0x4
    // Offset: 0x314
    int propBkgRt;
    // Field size check
    static_assert(sizeof(int) == 0x4);
    // private System.Int32 _propMaskRt
    // Size: 0x4
    // Offset: 0x318
    int propMaskRt;
    // Field size check
    static_assert(sizeof(int) == 0x4);
    // private System.Int32 _propSkybox
    // Size: 0x4
    // Offset: 0x31C
    int propSkybox;
    // Field size check
    static_assert(sizeof(int) == 0x4);
    // private System.Int32 _propOverlay
    // Size: 0x4
    // Offset: 0x320
    int propOverlay;
    // Field size check
    static_assert(sizeof(int) == 0x4);
    // private System.Int32 _propBlur
    // Size: 0x4
    // Offset: 0x324
    int propBlur;
    // Field size check
    static_assert(sizeof(int) == 0x4);
    // private System.Int32 _propBlurOffsets
    // Size: 0x4
    // Offset: 0x328
    int propBlurOffsets;
    // Field size check
    static_assert(sizeof(int) == 0x4);
    // private System.Int32 _globPropWorld2Cage
    // Size: 0x4
    // Offset: 0x32C
    int globPropWorld2Cage;
    // Field size check
    static_assert(sizeof(int) == 0x4);
    // private System.Int32 _globPropWorld2CageNormal
    // Size: 0x4
    // Offset: 0x330
    int globPropWorld2CageNormal;
    // Field size check
    static_assert(sizeof(int) == 0x4);
    // private System.Int32 _globPropCagePos
    // Size: 0x4
    // Offset: 0x334
    int globPropCagePos;
    // Field size check
    static_assert(sizeof(int) == 0x4);
    public:
    // static field const value: static private System.String KEYWORD_MASK
    static constexpr const char* KEYWORD_MASK = "TUNNEL_MASK";
    // Get static field: static private System.String KEYWORD_MASK
    static ::StringW _get_KEYWORD_MASK();
    // Set static field: static private System.String KEYWORD_MASK
    static void _set_KEYWORD_MASK(::StringW value);
    // static field const value: static private System.String KEYWORD_CONSTANT
    static constexpr const char* KEYWORD_CONSTANT = "TUNNEL_CONSTANT";
    // Get static field: static private System.String KEYWORD_CONSTANT
    static ::StringW _get_KEYWORD_CONSTANT();
    // Set static field: static private System.String KEYWORD_CONSTANT
    static void _set_KEYWORD_CONSTANT(::StringW value);
    // static field const value: static private System.String KEYWORD_INVERT
    static constexpr const char* KEYWORD_INVERT = "TUNNEL_INVERT_MASK";
    // Get static field: static private System.String KEYWORD_INVERT
    static ::StringW _get_KEYWORD_INVERT();
    // Set static field: static private System.String KEYWORD_INVERT
    static void _set_KEYWORD_INVERT(::StringW value);
    // static field const value: static private System.String KEYWORD_BLUR
    static constexpr const char* KEYWORD_BLUR = "TUNNEL_BLUR";
    // Get static field: static private System.String KEYWORD_BLUR
    static ::StringW _get_KEYWORD_BLUR();
    // Set static field: static private System.String KEYWORD_BLUR
    static void _set_KEYWORD_BLUR(::StringW value);
    // static field const value: static private System.String PATH_TUNNELSHADER
    static constexpr const char* PATH_TUNNELSHADER = "Tunnelling";
    // Get static field: static private System.String PATH_TUNNELSHADER
    static ::StringW _get_PATH_TUNNELSHADER();
    // Set static field: static private System.String PATH_TUNNELSHADER
    static void _set_PATH_TUNNELSHADER(::StringW value);
    // static field const value: static private System.String PATH_MASKSHADER
    static constexpr const char* PATH_MASKSHADER = "Mask";
    // Get static field: static private System.String PATH_MASKSHADER
    static ::StringW _get_PATH_MASKSHADER();
    // Set static field: static private System.String PATH_MASKSHADER
    static void _set_PATH_MASKSHADER(::StringW value);
    // static field const value: static private System.String PATH_WINDOWSHADER
    static constexpr const char* PATH_WINDOWSHADER = "Window";
    // Get static field: static private System.String PATH_WINDOWSHADER
    static ::StringW _get_PATH_WINDOWSHADER();
    // Set static field: static private System.String PATH_WINDOWSHADER
    static void _set_PATH_WINDOWSHADER(::StringW value);
    // static field const value: static private System.String PATH_COPYSHADER
    static constexpr const char* PATH_COPYSHADER = "BlitA";
    // Get static field: static private System.String PATH_COPYSHADER
    static ::StringW _get_PATH_COPYSHADER();
    // Set static field: static private System.String PATH_COPYSHADER
    static void _set_PATH_COPYSHADER(::StringW value);
    // static field const value: static private System.String PATH_BLURSHADER
    static constexpr const char* PATH_BLURSHADER = "SeparableBlur";
    // Get static field: static private System.String PATH_BLURSHADER
    static ::StringW _get_PATH_BLURSHADER();
    // Set static field: static private System.String PATH_BLURSHADER
    static void _set_PATH_BLURSHADER(::StringW value);
    // static field const value: static private System.String PATH_IRISSHADER
    static constexpr const char* PATH_IRISSHADER = "TunnellingVertexZ";
    // Get static field: static private System.String PATH_IRISSHADER
    static ::StringW _get_PATH_IRISSHADER();
    // Set static field: static private System.String PATH_IRISSHADER
    static void _set_PATH_IRISSHADER(::StringW value);
    // static field const value: static private System.String PATH_SKYSPHERESHADER
    static constexpr const char* PATH_SKYSPHERESHADER = "Skysphere";
    // Get static field: static private System.String PATH_SKYSPHERESHADER
    static ::StringW _get_PATH_SKYSPHERESHADER();
    // Set static field: static private System.String PATH_SKYSPHERESHADER
    static void _set_PATH_SKYSPHERESHADER(::StringW value);
    // static field const value: static private System.String PATH_SKYSPHEREMESH
    static constexpr const char* PATH_SKYSPHEREMESH = "Skysphere";
    // Get static field: static private System.String PATH_SKYSPHEREMESH
    static ::StringW _get_PATH_SKYSPHEREMESH();
    // Set static field: static private System.String PATH_SKYSPHEREMESH
    static void _set_PATH_SKYSPHEREMESH(::StringW value);
    // static field const value: static private System.String PROP_FEATHER
    static constexpr const char* PROP_FEATHER = "_Feather";
    // Get static field: static private System.String PROP_FEATHER
    static ::StringW _get_PROP_FEATHER();
    // Set static field: static private System.String PROP_FEATHER
    static void _set_PROP_FEATHER(::StringW value);
    // static field const value: static private System.String PROP_BKGRT
    static constexpr const char* PROP_BKGRT = "_BkgTex";
    // Get static field: static private System.String PROP_BKGRT
    static ::StringW _get_PROP_BKGRT();
    // Set static field: static private System.String PROP_BKGRT
    static void _set_PROP_BKGRT(::StringW value);
    // static field const value: static private System.String PROP_MASKRT
    static constexpr const char* PROP_MASKRT = "_MaskTex";
    // Get static field: static private System.String PROP_MASKRT
    static ::StringW _get_PROP_MASKRT();
    // Set static field: static private System.String PROP_MASKRT
    static void _set_PROP_MASKRT(::StringW value);
    // static field const value: static private System.String PROP_BLUR
    static constexpr const char* PROP_BLUR = "_Blur";
    // Get static field: static private System.String PROP_BLUR
    static ::StringW _get_PROP_BLUR();
    // Set static field: static private System.String PROP_BLUR
    static void _set_PROP_BLUR(::StringW value);
    // static field const value: static private System.String PROP_OVERLAY
    static constexpr const char* PROP_OVERLAY = "_Overlay";
    // Get static field: static private System.String PROP_OVERLAY
    static ::StringW _get_PROP_OVERLAY();
    // Set static field: static private System.String PROP_OVERLAY
    static void _set_PROP_OVERLAY(::StringW value);
    // static field const value: static private System.String PROP_BLUR_OFFSETS
    static constexpr const char* PROP_BLUR_OFFSETS = "_Offsets";
    // Get static field: static private System.String PROP_BLUR_OFFSETS
    static ::StringW _get_PROP_BLUR_OFFSETS();
    // Set static field: static private System.String PROP_BLUR_OFFSETS
    static void _set_PROP_BLUR_OFFSETS(::StringW value);
    // static field const value: static private System.Single BLUR_OFFSET_1
    static constexpr const float BLUR_OFFSET_1 = 1.3333334;
    // Get static field: static private System.Single BLUR_OFFSET_1
    static float _get_BLUR_OFFSET_1();
    // Set static field: static private System.Single BLUR_OFFSET_1
    static void _set_BLUR_OFFSET_1(float value);
    // Get static field: static private readonly System.Single[] BLUR_OFFSETS_9
    static ::ArrayW<float> _get_BLUR_OFFSETS_9();
    // Set static field: static private readonly System.Single[] BLUR_OFFSETS_9
    static void _set_BLUR_OFFSETS_9(::ArrayW<float> value);
    // Get static field: static private readonly System.Single[] BLUR_OFFSETS_13
    static ::ArrayW<float> _get_BLUR_OFFSETS_13();
    // Set static field: static private readonly System.Single[] BLUR_OFFSETS_13
    static void _set_BLUR_OFFSETS_13(::ArrayW<float> value);
    // static field const value: static public System.String GLOBAL_PROP_WORLD2CAGE
    static constexpr const char* GLOBAL_PROP_WORLD2CAGE = "_VRTP_WorldToCage";
    // Get static field: static public System.String GLOBAL_PROP_WORLD2CAGE
    static ::StringW _get_GLOBAL_PROP_WORLD2CAGE();
    // Set static field: static public System.String GLOBAL_PROP_WORLD2CAGE
    static void _set_GLOBAL_PROP_WORLD2CAGE(::StringW value);
    // static field const value: static public System.String GLOBAL_PROP_WORLD2CAGE_NORMAL
    static constexpr const char* GLOBAL_PROP_WORLD2CAGE_NORMAL = "_VRTP_WorldToCageNormal";
    // Get static field: static public System.String GLOBAL_PROP_WORLD2CAGE_NORMAL
    static ::StringW _get_GLOBAL_PROP_WORLD2CAGE_NORMAL();
    // Set static field: static public System.String GLOBAL_PROP_WORLD2CAGE_NORMAL
    static void _set_GLOBAL_PROP_WORLD2CAGE_NORMAL(::StringW value);
    // static field const value: static public System.String GLOBAL_PROP_CAGEPOS
    static constexpr const char* GLOBAL_PROP_CAGEPOS = "_VRTP_CagePos";
    // Get static field: static public System.String GLOBAL_PROP_CAGEPOS
    static ::StringW _get_GLOBAL_PROP_CAGEPOS();
    // Set static field: static public System.String GLOBAL_PROP_CAGEPOS
    static void _set_GLOBAL_PROP_CAGEPOS(::StringW value);
    // Get static field: static private Sigtrap.VrTunnellingPro.TunnellingImageBase <instance>k__BackingField
    static ::Sigtrap::VrTunnellingPro::TunnellingImageBase* _get_$instance$k__BackingField();
    // Set static field: static private Sigtrap.VrTunnellingPro.TunnellingImageBase <instance>k__BackingField
    static void _set_$instance$k__BackingField(::Sigtrap::VrTunnellingPro::TunnellingImageBase* value);
    // Get instance field reference: public Sigtrap.VrTunnellingPro.TunnellingBase/Sigtrap.VrTunnellingPro.BackgroundMode backgroundMode
    ::Sigtrap::VrTunnellingPro::TunnellingBase::BackgroundMode& dyn_backgroundMode();
    // Get instance field reference: public System.Single effectOverlay
    float& dyn_effectOverlay();
    // Get instance field reference: private UnityEngine.GameObject _cageParent
    ::UnityEngine::GameObject*& dyn__cageParent();
    // Get instance field reference: public System.Int32 cageDownsample
    int& dyn_cageDownsample();
    // Get instance field reference: public Sigtrap.VrTunnellingPro.TunnellingBase/Sigtrap.VrTunnellingPro.MSAA cageAntiAliasing
    ::Sigtrap::VrTunnellingPro::TunnellingBase::MSAA& dyn_cageAntiAliasing();
    // Get instance field reference: public System.Boolean cageUpdateEveryFrame
    bool& dyn_cageUpdateEveryFrame();
    // Get instance field reference: public System.Single cageFogDensity
    float& dyn_cageFogDensity();
    // Get instance field reference: public System.Single cageFogPower
    float& dyn_cageFogPower();
    // Get instance field reference: public System.Single cageFogBlend
    float& dyn_cageFogBlend();
    // Get instance field reference: public Sigtrap.VrTunnellingPro.TunnellingBase/Sigtrap.VrTunnellingPro.MaskMode maskMode
    ::Sigtrap::VrTunnellingPro::TunnellingBase::MaskMode& dyn_maskMode();
    // Get instance field reference: public System.Int32 blurDownsample
    int& dyn_blurDownsample();
    // Get instance field reference: public System.Single blurDistance
    float& dyn_blurDistance();
    // Get instance field reference: public System.Int32 blurPasses
    int& dyn_blurPasses();
    // Get instance field reference: public Sigtrap.VrTunnellingPro.TunnellingImageBase/Sigtrap.VrTunnellingPro.BlurKernel blurSamples
    ::Sigtrap::VrTunnellingPro::TunnellingImageBase::BlurKernel& dyn_blurSamples();
    // Get instance field reference: public System.Boolean irisZRejection
    bool& dyn_irisZRejection();
    // Get instance field reference: public Sigtrap.VrTunnellingPro.TunnellingImageBase/Sigtrap.VrTunnellingPro.CounterVelocityMode counterVelocityMode
    ::Sigtrap::VrTunnellingPro::TunnellingImageBase::CounterVelocityMode& dyn_counterVelocityMode();
    // Get instance field reference: public System.Single counterVelocityResetDistance
    float& dyn_counterVelocityResetDistance();
    // Get instance field reference: public System.Single counterVelocityResetTime
    float& dyn_counterVelocityResetTime();
    // Get instance field reference: public System.Single counterVelocityStrength
    float& dyn_counterVelocityStrength();
    // Get instance field reference: public UnityEngine.Vector3 counterVelocityPerAxis
    ::UnityEngine::Vector3& dyn_counterVelocityPerAxis();
    // Get instance field reference: private UnityEngine.Rendering.CommandBuffer _maskCmd
    ::UnityEngine::Rendering::CommandBuffer*& dyn__maskCmd();
    // Get instance field reference: private UnityEngine.Material _matTunnel
    ::UnityEngine::Material*& dyn__matTunnel();
    // Get instance field reference: private UnityEngine.Material _matMask
    ::UnityEngine::Material*& dyn__matMask();
    // Get instance field reference: private UnityEngine.Material _matWindow
    ::UnityEngine::Material*& dyn__matWindow();
    // Get instance field reference: private UnityEngine.Material _matCopyAlpha
    ::UnityEngine::Material*& dyn__matCopyAlpha();
    // Get instance field reference: private UnityEngine.Material _matBlur
    ::UnityEngine::Material*& dyn__matBlur();
    // Get instance field reference: private UnityEngine.Material _matSkysphere
    ::UnityEngine::Material*& dyn__matSkysphere();
    // Get instance field reference: private UnityEngine.Mesh _meshSkysphere
    ::UnityEngine::Mesh*& dyn__meshSkysphere();
    // Get instance field reference: private UnityEngine.MeshRenderer[] _cageMrs
    ::ArrayW<::UnityEngine::MeshRenderer*>& dyn__cageMrs();
    // Get instance field reference: private System.Collections.Generic.List`1<UnityEngine.MeshFilter> _cageMfs
    ::System::Collections::Generic::List_1<::UnityEngine::MeshFilter*>*& dyn__cageMfs();
    // Get instance field reference: private System.Collections.Generic.List`1<UnityEngine.Renderer> _maskObjects
    ::System::Collections::Generic::List_1<::UnityEngine::Renderer*>*& dyn__maskObjects();
    // Get instance field reference: private UnityEngine.RenderTexture _cageRt
    ::UnityEngine::RenderTexture*& dyn__cageRt();
    // Get instance field reference: private UnityEngine.RenderTexture _maskRt
    ::UnityEngine::RenderTexture*& dyn__maskRt();
    // Get instance field reference: private UnityEngine.RenderTexture _blurRt0
    ::UnityEngine::RenderTexture*& dyn__blurRt0();
    // Get instance field reference: private UnityEngine.RenderTexture _blurRt1
    ::UnityEngine::RenderTexture*& dyn__blurRt1();
    // Get instance field reference: private System.Int32 _rtX
    int& dyn__rtX();
    // Get instance field reference: private System.Int32 _rtY
    int& dyn__rtY();
    // Get instance field reference: private System.Int32 _rtA
    int& dyn__rtA();
    // Get instance field reference: private UnityEngine.Rendering.CommandBuffer _irisCmd
    ::UnityEngine::Rendering::CommandBuffer*& dyn__irisCmd();
    // Get instance field reference: private UnityEngine.Material _matIris
    ::UnityEngine::Material*& dyn__matIris();
    // Get instance field reference: private UnityEngine.Mesh _meshIris
    ::UnityEngine::Mesh*& dyn__meshIris();
    // Get instance field reference: private UnityEngine.Vector4[] _blurOffsets
    ::ArrayW<::UnityEngine::Vector4>& dyn__blurOffsets();
    // Get instance field reference: private Sigtrap.VrTunnellingPro.TunnellingBase/Sigtrap.VrTunnellingPro.MaskMode _lastMaskMode
    ::Sigtrap::VrTunnellingPro::TunnellingBase::MaskMode& dyn__lastMaskMode();
    // Get instance field reference: private Sigtrap.VrTunnellingPro.TunnellingBase/Sigtrap.VrTunnellingPro.MSAA _lastCageMsaa
    ::Sigtrap::VrTunnellingPro::TunnellingBase::MSAA& dyn__lastCageMsaa();
    // Get instance field reference: private System.Boolean _camHasMaskBuffer
    bool& dyn__camHasMaskBuffer();
    // Get instance field reference: private System.Int32 _lastCageDownsample
    int& dyn__lastCageDownsample();
    // Get instance field reference: private System.Int32 _lastBlurDownsample
    int& dyn__lastBlurDownsample();
    // Get instance field reference: private System.Single _lastBlurRadius
    float& dyn__lastBlurRadius();
    // Get instance field reference: private Sigtrap.VrTunnellingPro.TunnellingImageBase/Sigtrap.VrTunnellingPro.BlurKernel _lastBlurKernel
    ::Sigtrap::VrTunnellingPro::TunnellingImageBase::BlurKernel& dyn__lastBlurKernel();
    // Get instance field reference: private System.Boolean _wasDrawingIrisEarly
    bool& dyn__wasDrawingIrisEarly();
    // Get instance field reference: private System.Boolean _camHasIrisBuffer
    bool& dyn__camHasIrisBuffer();
    // Get instance field reference: private Sigtrap.VrTunnellingPro.TunnellingImageBase/Sigtrap.VrTunnellingPro.CounterVelocityMode _lastCvMode
    ::Sigtrap::VrTunnellingPro::TunnellingImageBase::CounterVelocityMode& dyn__lastCvMode();
    // Get instance field reference: private UnityEngine.Vector3 _cmPos
    ::UnityEngine::Vector3& dyn__cmPos();
    // Get instance field reference: private UnityEngine.Vector3 _cageInitialPosLocal
    ::UnityEngine::Vector3& dyn__cageInitialPosLocal();
    // Get instance field reference: private System.Single _timeToResetCounterVelocity
    float& dyn__timeToResetCounterVelocity();
    // Get instance field reference: private System.Int32 _propColor
    int& dyn__propColor();
    // Get instance field reference: private System.Int32 _propBkgRt
    int& dyn__propBkgRt();
    // Get instance field reference: private System.Int32 _propMaskRt
    int& dyn__propMaskRt();
    // Get instance field reference: private System.Int32 _propSkybox
    int& dyn__propSkybox();
    // Get instance field reference: private System.Int32 _propOverlay
    int& dyn__propOverlay();
    // Get instance field reference: private System.Int32 _propBlur
    int& dyn__propBlur();
    // Get instance field reference: private System.Int32 _propBlurOffsets
    int& dyn__propBlurOffsets();
    // Get instance field reference: private System.Int32 _globPropWorld2Cage
    int& dyn__globPropWorld2Cage();
    // Get instance field reference: private System.Int32 _globPropWorld2CageNormal
    int& dyn__globPropWorld2CageNormal();
    // Get instance field reference: private System.Int32 _globPropCagePos
    int& dyn__globPropCagePos();
    // static public Sigtrap.VrTunnellingPro.TunnellingImageBase get_instance()
    // Offset: 0x10BCFB4
    static ::Sigtrap::VrTunnellingPro::TunnellingImageBase* get_instance();
    // static private System.Void set_instance(Sigtrap.VrTunnellingPro.TunnellingImageBase value)
    // Offset: 0x10BD01C
    static void set_instance(::Sigtrap::VrTunnellingPro::TunnellingImageBase* value);
    // public System.Boolean get_usingMask()
    // Offset: 0x10BD088
    bool get_usingMask();
    // public System.Boolean get_usingCage()
    // Offset: 0x10BD098
    bool get_usingCage();
    // private System.Boolean get__usingCageRt()
    // Offset: 0x10BD0BC
    bool get__usingCageRt();
    // private System.Boolean get__canDrawIris()
    // Offset: 0x10BD0D0
    bool get__canDrawIris();
    // private System.Boolean get__drawIris()
    // Offset: 0x10BD104
    bool get__drawIris();
    // private System.Boolean get__isInstanced()
    // Offset: 0x10BD140
    bool get__isInstanced();
    // protected UnityEngine.Rendering.CameraEvent get__maskCmdEvt()
    // Offset: 0xFFFFFFFF
    ::UnityEngine::Rendering::CameraEvent get__maskCmdEvt();
    // private System.Void OnDisable()
    // Offset: 0x10BDD20
    void OnDisable();
    // private System.Void OnDestroy()
    // Offset: 0x10BDDA4
    void OnDestroy();
    // private System.Void ReleaseRT(ref UnityEngine.RenderTexture rt)
    // Offset: 0x10BDFB0
    void ReleaseRT(ByRef<::UnityEngine::RenderTexture*> rt);
    // public System.Void AddObjectToMask(UnityEngine.Renderer r, System.Boolean includeChildren)
    // Offset: 0x10BE040
    void AddObjectToMask(::UnityEngine::Renderer* r, bool includeChildren);
    // public System.Void RemoveObjectFromMask(UnityEngine.Renderer r, System.Boolean includeChildren)
    // Offset: 0x10BE310
    void RemoveObjectFromMask(::UnityEngine::Renderer* r, bool includeChildren);
    // public System.Void UpdateCage()
    // Offset: 0x10BDA4C
    void UpdateCage();
    // public System.Void ApplyPreset(Sigtrap.VrTunnellingPro.TunnellingPreset p)
    // Offset: 0x10BE4E8
    void ApplyPreset(::Sigtrap::VrTunnellingPro::TunnellingPreset* p);
    // private System.Void LateUpdate()
    // Offset: 0x10BE91C
    void LateUpdate();
    // private System.Void OnPreRender()
    // Offset: 0x10BEFB4
    void OnPreRender();
    // protected System.Void Draw(UnityEngine.RenderTexture src, UnityEngine.RenderTexture dest)
    // Offset: 0x10BAA38
    void Draw(::UnityEngine::RenderTexture* src, ::UnityEngine::RenderTexture* dest);
    // private System.Void UpdateKeywords()
    // Offset: 0x10BD71C
    void UpdateKeywords();
    // private System.Void UpdateBlurKernel()
    // Offset: 0x10BECD0
    void UpdateBlurKernel();
    // private System.Int32 GetMsaa(Sigtrap.VrTunnellingPro.TunnellingBase/Sigtrap.VrTunnellingPro.MSAA m, System.Int32 srcMsaa)
    // Offset: 0x10BFBCC
    int GetMsaa(::Sigtrap::VrTunnellingPro::TunnellingBase::MSAA m, int srcMsaa);
    // private System.Void SetTexArrayIfNeeded(UnityEngine.RenderTexture target)
    // Offset: 0x10BFBF0
    void SetTexArrayIfNeeded(::UnityEngine::RenderTexture* target);
    // private System.Void UpdateRenderTextures(System.Int32 srcX, System.Int32 srcY, System.Int32 srcMsaa)
    // Offset: 0x10BF1EC
    void UpdateRenderTextures(int srcX, int srcY, int srcMsaa);
    // private System.Void ResetMaskCommandBuffer()
    // Offset: 0x10BE130
    void ResetMaskCommandBuffer();
    // private System.Void ToggleMaskCommandBuffer(System.Boolean on)
    // Offset: 0x10BDC58
    void ToggleMaskCommandBuffer(bool on);
    // private System.Void ToggleIrisCommandBuffer(System.Boolean on)
    // Offset: 0x10BDCC8
    void ToggleIrisCommandBuffer(bool on);
    // protected System.Void .ctor()
    // Offset: 0x10BAF88
    // Implemented from: Sigtrap.VrTunnellingPro.TunnellingBase
    // Base method: System.Void TunnellingBase::.ctor()
    // Base method: System.Void MonoBehaviour::.ctor()
    // Base method: System.Void Behaviour::.ctor()
    // Base method: System.Void Component::.ctor()
    // Base method: System.Void Object::.ctor()
    // Base method: System.Void Object::.ctor()
    template<::il2cpp_utils::CreationType creationType = ::il2cpp_utils::CreationType::Temporary>
    static TunnellingImageBase* New_ctor() {
      static auto ___internal__logger = ::Logger::get().WithContext("::Sigtrap::VrTunnellingPro::TunnellingImageBase::.ctor");
      return THROW_UNLESS((::il2cpp_utils::New<TunnellingImageBase*, creationType>()));
    }
    // static private System.Void .cctor()
    // Offset: 0x10BFC60
    // Implemented from: UnityEngine.Object
    // Base method: System.Void Object::.cctor()
    static void _cctor();
    // protected override System.Void Awake()
    // Offset: 0x10BD178
    // Implemented from: Sigtrap.VrTunnellingPro.TunnellingBase
    // Base method: System.Void TunnellingBase::Awake()
    void Awake();
    // protected override System.Void OnEnable()
    // Offset: 0x10BD9BC
    // Implemented from: Sigtrap.VrTunnellingPro.TunnellingBase
    // Base method: System.Void TunnellingBase::OnEnable()
    void OnEnable();
    // public override System.Void ResetCounterMotion()
    // Offset: 0x10BE400
    // Implemented from: Sigtrap.VrTunnellingPro.TunnellingBase
    // Base method: System.Void TunnellingBase::ResetCounterMotion()
    void ResetCounterMotion();
    // protected override System.Void CorrectEyeMatrices(UnityEngine.Matrix4x4[] eyePrj, UnityEngine.Matrix4x4[] eyeToWorld)
    // Offset: 0x10BF850
    // Implemented from: Sigtrap.VrTunnellingPro.TunnellingBase
    // Base method: System.Void TunnellingBase::CorrectEyeMatrices(UnityEngine.Matrix4x4[] eyePrj, UnityEngine.Matrix4x4[] eyeToWorld)
    void CorrectEyeMatrices(::ArrayW<::UnityEngine::Matrix4x4> eyePrj, ::ArrayW<::UnityEngine::Matrix4x4> eyeToWorld);
    // protected override System.Void UpdateCounterMotion(UnityEngine.Vector3 deltaPos, UnityEngine.Quaternion deltaRot)
    // Offset: 0x10BF8D0
    // Implemented from: Sigtrap.VrTunnellingPro.TunnellingBase
    // Base method: System.Void TunnellingBase::UpdateCounterMotion(UnityEngine.Vector3 deltaPos, UnityEngine.Quaternion deltaRot)
    void UpdateCounterMotion(::UnityEngine::Vector3 deltaPos, ::UnityEngine::Quaternion deltaRot);
  }; // Sigtrap.VrTunnellingPro.TunnellingImageBase
  #pragma pack(pop)
  static check_size<sizeof(TunnellingImageBase), 820 + sizeof(int)> __Sigtrap_VrTunnellingPro_TunnellingImageBaseSizeCheck;
  static_assert(sizeof(TunnellingImageBase) == 0x338);
}
#include "beatsaber-hook/shared/utils/il2cpp-type-check.hpp"
DEFINE_IL2CPP_ARG_TYPE(::Sigtrap::VrTunnellingPro::TunnellingImageBase::CounterVelocityMode, "Sigtrap.VrTunnellingPro", "TunnellingImageBase/CounterVelocityMode");
#include "beatsaber-hook/shared/utils/il2cpp-type-check.hpp"
DEFINE_IL2CPP_ARG_TYPE(::Sigtrap::VrTunnellingPro::TunnellingImageBase::BlurKernel, "Sigtrap.VrTunnellingPro", "TunnellingImageBase/BlurKernel");
#include "beatsaber-hook/shared/utils/il2cpp-utils-methods.hpp"
// Writing MetadataGetter for method: Sigtrap::VrTunnellingPro::TunnellingImageBase::get_instance
// Il2CppName: get_instance
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<::Sigtrap::VrTunnellingPro::TunnellingImageBase* (*)()>(&Sigtrap::VrTunnellingPro::TunnellingImageBase::get_instance)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(Sigtrap::VrTunnellingPro::TunnellingImageBase*), "get_instance", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: Sigtrap::VrTunnellingPro::TunnellingImageBase::set_instance
// Il2CppName: set_instance
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (*)(::Sigtrap::VrTunnellingPro::TunnellingImageBase*)>(&Sigtrap::VrTunnellingPro::TunnellingImageBase::set_instance)> {
  static const MethodInfo* get() {
    static auto* value = &::il2cpp_utils::GetClassFromName("Sigtrap.VrTunnellingPro", "TunnellingImageBase")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(Sigtrap::VrTunnellingPro::TunnellingImageBase*), "set_instance", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{value});
  }
};
// Writing MetadataGetter for method: Sigtrap::VrTunnellingPro::TunnellingImageBase::get_usingMask
// Il2CppName: get_usingMask
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<bool (Sigtrap::VrTunnellingPro::TunnellingImageBase::*)()>(&Sigtrap::VrTunnellingPro::TunnellingImageBase::get_usingMask)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(Sigtrap::VrTunnellingPro::TunnellingImageBase*), "get_usingMask", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: Sigtrap::VrTunnellingPro::TunnellingImageBase::get_usingCage
// Il2CppName: get_usingCage
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<bool (Sigtrap::VrTunnellingPro::TunnellingImageBase::*)()>(&Sigtrap::VrTunnellingPro::TunnellingImageBase::get_usingCage)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(Sigtrap::VrTunnellingPro::TunnellingImageBase*), "get_usingCage", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: Sigtrap::VrTunnellingPro::TunnellingImageBase::get__usingCageRt
// Il2CppName: get__usingCageRt
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<bool (Sigtrap::VrTunnellingPro::TunnellingImageBase::*)()>(&Sigtrap::VrTunnellingPro::TunnellingImageBase::get__usingCageRt)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(Sigtrap::VrTunnellingPro::TunnellingImageBase*), "get__usingCageRt", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: Sigtrap::VrTunnellingPro::TunnellingImageBase::get__canDrawIris
// Il2CppName: get__canDrawIris
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<bool (Sigtrap::VrTunnellingPro::TunnellingImageBase::*)()>(&Sigtrap::VrTunnellingPro::TunnellingImageBase::get__canDrawIris)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(Sigtrap::VrTunnellingPro::TunnellingImageBase*), "get__canDrawIris", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: Sigtrap::VrTunnellingPro::TunnellingImageBase::get__drawIris
// Il2CppName: get__drawIris
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<bool (Sigtrap::VrTunnellingPro::TunnellingImageBase::*)()>(&Sigtrap::VrTunnellingPro::TunnellingImageBase::get__drawIris)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(Sigtrap::VrTunnellingPro::TunnellingImageBase*), "get__drawIris", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: Sigtrap::VrTunnellingPro::TunnellingImageBase::get__isInstanced
// Il2CppName: get__isInstanced
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<bool (Sigtrap::VrTunnellingPro::TunnellingImageBase::*)()>(&Sigtrap::VrTunnellingPro::TunnellingImageBase::get__isInstanced)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(Sigtrap::VrTunnellingPro::TunnellingImageBase*), "get__isInstanced", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: Sigtrap::VrTunnellingPro::TunnellingImageBase::get__maskCmdEvt
// Il2CppName: get__maskCmdEvt
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<::UnityEngine::Rendering::CameraEvent (Sigtrap::VrTunnellingPro::TunnellingImageBase::*)()>(&Sigtrap::VrTunnellingPro::TunnellingImageBase::get__maskCmdEvt)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(Sigtrap::VrTunnellingPro::TunnellingImageBase*), "get__maskCmdEvt", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: Sigtrap::VrTunnellingPro::TunnellingImageBase::OnDisable
// Il2CppName: OnDisable
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (Sigtrap::VrTunnellingPro::TunnellingImageBase::*)()>(&Sigtrap::VrTunnellingPro::TunnellingImageBase::OnDisable)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(Sigtrap::VrTunnellingPro::TunnellingImageBase*), "OnDisable", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: Sigtrap::VrTunnellingPro::TunnellingImageBase::OnDestroy
// Il2CppName: OnDestroy
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (Sigtrap::VrTunnellingPro::TunnellingImageBase::*)()>(&Sigtrap::VrTunnellingPro::TunnellingImageBase::OnDestroy)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(Sigtrap::VrTunnellingPro::TunnellingImageBase*), "OnDestroy", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: Sigtrap::VrTunnellingPro::TunnellingImageBase::ReleaseRT
// Il2CppName: ReleaseRT
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (Sigtrap::VrTunnellingPro::TunnellingImageBase::*)(ByRef<::UnityEngine::RenderTexture*>)>(&Sigtrap::VrTunnellingPro::TunnellingImageBase::ReleaseRT)> {
  static const MethodInfo* get() {
    static auto* rt = &::il2cpp_utils::GetClassFromName("UnityEngine", "RenderTexture")->this_arg;
    return ::il2cpp_utils::FindMethod(classof(Sigtrap::VrTunnellingPro::TunnellingImageBase*), "ReleaseRT", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{rt});
  }
};
// Writing MetadataGetter for method: Sigtrap::VrTunnellingPro::TunnellingImageBase::AddObjectToMask
// Il2CppName: AddObjectToMask
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (Sigtrap::VrTunnellingPro::TunnellingImageBase::*)(::UnityEngine::Renderer*, bool)>(&Sigtrap::VrTunnellingPro::TunnellingImageBase::AddObjectToMask)> {
  static const MethodInfo* get() {
    static auto* r = &::il2cpp_utils::GetClassFromName("UnityEngine", "Renderer")->byval_arg;
    static auto* includeChildren = &::il2cpp_utils::GetClassFromName("System", "Boolean")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(Sigtrap::VrTunnellingPro::TunnellingImageBase*), "AddObjectToMask", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{r, includeChildren});
  }
};
// Writing MetadataGetter for method: Sigtrap::VrTunnellingPro::TunnellingImageBase::RemoveObjectFromMask
// Il2CppName: RemoveObjectFromMask
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (Sigtrap::VrTunnellingPro::TunnellingImageBase::*)(::UnityEngine::Renderer*, bool)>(&Sigtrap::VrTunnellingPro::TunnellingImageBase::RemoveObjectFromMask)> {
  static const MethodInfo* get() {
    static auto* r = &::il2cpp_utils::GetClassFromName("UnityEngine", "Renderer")->byval_arg;
    static auto* includeChildren = &::il2cpp_utils::GetClassFromName("System", "Boolean")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(Sigtrap::VrTunnellingPro::TunnellingImageBase*), "RemoveObjectFromMask", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{r, includeChildren});
  }
};
// Writing MetadataGetter for method: Sigtrap::VrTunnellingPro::TunnellingImageBase::UpdateCage
// Il2CppName: UpdateCage
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (Sigtrap::VrTunnellingPro::TunnellingImageBase::*)()>(&Sigtrap::VrTunnellingPro::TunnellingImageBase::UpdateCage)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(Sigtrap::VrTunnellingPro::TunnellingImageBase*), "UpdateCage", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: Sigtrap::VrTunnellingPro::TunnellingImageBase::ApplyPreset
// Il2CppName: ApplyPreset
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (Sigtrap::VrTunnellingPro::TunnellingImageBase::*)(::Sigtrap::VrTunnellingPro::TunnellingPreset*)>(&Sigtrap::VrTunnellingPro::TunnellingImageBase::ApplyPreset)> {
  static const MethodInfo* get() {
    static auto* p = &::il2cpp_utils::GetClassFromName("Sigtrap.VrTunnellingPro", "TunnellingPreset")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(Sigtrap::VrTunnellingPro::TunnellingImageBase*), "ApplyPreset", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{p});
  }
};
// Writing MetadataGetter for method: Sigtrap::VrTunnellingPro::TunnellingImageBase::LateUpdate
// Il2CppName: LateUpdate
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (Sigtrap::VrTunnellingPro::TunnellingImageBase::*)()>(&Sigtrap::VrTunnellingPro::TunnellingImageBase::LateUpdate)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(Sigtrap::VrTunnellingPro::TunnellingImageBase*), "LateUpdate", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: Sigtrap::VrTunnellingPro::TunnellingImageBase::OnPreRender
// Il2CppName: OnPreRender
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (Sigtrap::VrTunnellingPro::TunnellingImageBase::*)()>(&Sigtrap::VrTunnellingPro::TunnellingImageBase::OnPreRender)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(Sigtrap::VrTunnellingPro::TunnellingImageBase*), "OnPreRender", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: Sigtrap::VrTunnellingPro::TunnellingImageBase::Draw
// Il2CppName: Draw
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (Sigtrap::VrTunnellingPro::TunnellingImageBase::*)(::UnityEngine::RenderTexture*, ::UnityEngine::RenderTexture*)>(&Sigtrap::VrTunnellingPro::TunnellingImageBase::Draw)> {
  static const MethodInfo* get() {
    static auto* src = &::il2cpp_utils::GetClassFromName("UnityEngine", "RenderTexture")->byval_arg;
    static auto* dest = &::il2cpp_utils::GetClassFromName("UnityEngine", "RenderTexture")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(Sigtrap::VrTunnellingPro::TunnellingImageBase*), "Draw", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{src, dest});
  }
};
// Writing MetadataGetter for method: Sigtrap::VrTunnellingPro::TunnellingImageBase::UpdateKeywords
// Il2CppName: UpdateKeywords
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (Sigtrap::VrTunnellingPro::TunnellingImageBase::*)()>(&Sigtrap::VrTunnellingPro::TunnellingImageBase::UpdateKeywords)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(Sigtrap::VrTunnellingPro::TunnellingImageBase*), "UpdateKeywords", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: Sigtrap::VrTunnellingPro::TunnellingImageBase::UpdateBlurKernel
// Il2CppName: UpdateBlurKernel
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (Sigtrap::VrTunnellingPro::TunnellingImageBase::*)()>(&Sigtrap::VrTunnellingPro::TunnellingImageBase::UpdateBlurKernel)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(Sigtrap::VrTunnellingPro::TunnellingImageBase*), "UpdateBlurKernel", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: Sigtrap::VrTunnellingPro::TunnellingImageBase::GetMsaa
// Il2CppName: GetMsaa
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<int (Sigtrap::VrTunnellingPro::TunnellingImageBase::*)(::Sigtrap::VrTunnellingPro::TunnellingBase::MSAA, int)>(&Sigtrap::VrTunnellingPro::TunnellingImageBase::GetMsaa)> {
  static const MethodInfo* get() {
    static auto* m = &::il2cpp_utils::GetClassFromName("Sigtrap.VrTunnellingPro", "TunnellingBase/MSAA")->byval_arg;
    static auto* srcMsaa = &::il2cpp_utils::GetClassFromName("System", "Int32")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(Sigtrap::VrTunnellingPro::TunnellingImageBase*), "GetMsaa", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{m, srcMsaa});
  }
};
// Writing MetadataGetter for method: Sigtrap::VrTunnellingPro::TunnellingImageBase::SetTexArrayIfNeeded
// Il2CppName: SetTexArrayIfNeeded
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (Sigtrap::VrTunnellingPro::TunnellingImageBase::*)(::UnityEngine::RenderTexture*)>(&Sigtrap::VrTunnellingPro::TunnellingImageBase::SetTexArrayIfNeeded)> {
  static const MethodInfo* get() {
    static auto* target = &::il2cpp_utils::GetClassFromName("UnityEngine", "RenderTexture")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(Sigtrap::VrTunnellingPro::TunnellingImageBase*), "SetTexArrayIfNeeded", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{target});
  }
};
// Writing MetadataGetter for method: Sigtrap::VrTunnellingPro::TunnellingImageBase::UpdateRenderTextures
// Il2CppName: UpdateRenderTextures
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (Sigtrap::VrTunnellingPro::TunnellingImageBase::*)(int, int, int)>(&Sigtrap::VrTunnellingPro::TunnellingImageBase::UpdateRenderTextures)> {
  static const MethodInfo* get() {
    static auto* srcX = &::il2cpp_utils::GetClassFromName("System", "Int32")->byval_arg;
    static auto* srcY = &::il2cpp_utils::GetClassFromName("System", "Int32")->byval_arg;
    static auto* srcMsaa = &::il2cpp_utils::GetClassFromName("System", "Int32")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(Sigtrap::VrTunnellingPro::TunnellingImageBase*), "UpdateRenderTextures", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{srcX, srcY, srcMsaa});
  }
};
// Writing MetadataGetter for method: Sigtrap::VrTunnellingPro::TunnellingImageBase::ResetMaskCommandBuffer
// Il2CppName: ResetMaskCommandBuffer
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (Sigtrap::VrTunnellingPro::TunnellingImageBase::*)()>(&Sigtrap::VrTunnellingPro::TunnellingImageBase::ResetMaskCommandBuffer)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(Sigtrap::VrTunnellingPro::TunnellingImageBase*), "ResetMaskCommandBuffer", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: Sigtrap::VrTunnellingPro::TunnellingImageBase::ToggleMaskCommandBuffer
// Il2CppName: ToggleMaskCommandBuffer
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (Sigtrap::VrTunnellingPro::TunnellingImageBase::*)(bool)>(&Sigtrap::VrTunnellingPro::TunnellingImageBase::ToggleMaskCommandBuffer)> {
  static const MethodInfo* get() {
    static auto* on = &::il2cpp_utils::GetClassFromName("System", "Boolean")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(Sigtrap::VrTunnellingPro::TunnellingImageBase*), "ToggleMaskCommandBuffer", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{on});
  }
};
// Writing MetadataGetter for method: Sigtrap::VrTunnellingPro::TunnellingImageBase::ToggleIrisCommandBuffer
// Il2CppName: ToggleIrisCommandBuffer
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (Sigtrap::VrTunnellingPro::TunnellingImageBase::*)(bool)>(&Sigtrap::VrTunnellingPro::TunnellingImageBase::ToggleIrisCommandBuffer)> {
  static const MethodInfo* get() {
    static auto* on = &::il2cpp_utils::GetClassFromName("System", "Boolean")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(Sigtrap::VrTunnellingPro::TunnellingImageBase*), "ToggleIrisCommandBuffer", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{on});
  }
};
// Writing MetadataGetter for method: Sigtrap::VrTunnellingPro::TunnellingImageBase::New_ctor
// Il2CppName: .ctor
// Cannot get method pointer of value based method overload from template for constructor!
// Try using FindMethod instead!
// Writing MetadataGetter for method: Sigtrap::VrTunnellingPro::TunnellingImageBase::_cctor
// Il2CppName: .cctor
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (*)()>(&Sigtrap::VrTunnellingPro::TunnellingImageBase::_cctor)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(Sigtrap::VrTunnellingPro::TunnellingImageBase*), ".cctor", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: Sigtrap::VrTunnellingPro::TunnellingImageBase::Awake
// Il2CppName: Awake
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (Sigtrap::VrTunnellingPro::TunnellingImageBase::*)()>(&Sigtrap::VrTunnellingPro::TunnellingImageBase::Awake)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(Sigtrap::VrTunnellingPro::TunnellingImageBase*), "Awake", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: Sigtrap::VrTunnellingPro::TunnellingImageBase::OnEnable
// Il2CppName: OnEnable
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (Sigtrap::VrTunnellingPro::TunnellingImageBase::*)()>(&Sigtrap::VrTunnellingPro::TunnellingImageBase::OnEnable)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(Sigtrap::VrTunnellingPro::TunnellingImageBase*), "OnEnable", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: Sigtrap::VrTunnellingPro::TunnellingImageBase::ResetCounterMotion
// Il2CppName: ResetCounterMotion
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (Sigtrap::VrTunnellingPro::TunnellingImageBase::*)()>(&Sigtrap::VrTunnellingPro::TunnellingImageBase::ResetCounterMotion)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(Sigtrap::VrTunnellingPro::TunnellingImageBase*), "ResetCounterMotion", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: Sigtrap::VrTunnellingPro::TunnellingImageBase::CorrectEyeMatrices
// Il2CppName: CorrectEyeMatrices
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (Sigtrap::VrTunnellingPro::TunnellingImageBase::*)(::ArrayW<::UnityEngine::Matrix4x4>, ::ArrayW<::UnityEngine::Matrix4x4>)>(&Sigtrap::VrTunnellingPro::TunnellingImageBase::CorrectEyeMatrices)> {
  static const MethodInfo* get() {
    static auto* eyePrj = &il2cpp_functions::array_class_get(::il2cpp_utils::GetClassFromName("UnityEngine", "Matrix4x4"), 1)->byval_arg;
    static auto* eyeToWorld = &il2cpp_functions::array_class_get(::il2cpp_utils::GetClassFromName("UnityEngine", "Matrix4x4"), 1)->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(Sigtrap::VrTunnellingPro::TunnellingImageBase*), "CorrectEyeMatrices", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{eyePrj, eyeToWorld});
  }
};
// Writing MetadataGetter for method: Sigtrap::VrTunnellingPro::TunnellingImageBase::UpdateCounterMotion
// Il2CppName: UpdateCounterMotion
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (Sigtrap::VrTunnellingPro::TunnellingImageBase::*)(::UnityEngine::Vector3, ::UnityEngine::Quaternion)>(&Sigtrap::VrTunnellingPro::TunnellingImageBase::UpdateCounterMotion)> {
  static const MethodInfo* get() {
    static auto* deltaPos = &::il2cpp_utils::GetClassFromName("UnityEngine", "Vector3")->byval_arg;
    static auto* deltaRot = &::il2cpp_utils::GetClassFromName("UnityEngine", "Quaternion")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(Sigtrap::VrTunnellingPro::TunnellingImageBase*), "UpdateCounterMotion", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{deltaPos, deltaRot});
  }
};
