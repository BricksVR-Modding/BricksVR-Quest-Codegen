// Autogenerated from CppHeaderCreator
// Created by Sc2ad
// =========================================================================
#pragma once
// Begin includes
#include "beatsaber-hook/shared/utils/typedefs.h"
#include "beatsaber-hook/shared/utils/byref.hpp"
// Including type: Sigtrap.VrTunnellingPro.TunnellingBase
#include "Sigtrap/VrTunnellingPro/TunnellingBase.hpp"
// Including type: UnityEngine.Rendering.CameraEvent
#include "UnityEngine/Rendering/CameraEvent.hpp"
#include "beatsaber-hook/shared/utils/il2cpp-utils-methods.hpp"
#include "beatsaber-hook/shared/utils/il2cpp-utils-properties.hpp"
#include "beatsaber-hook/shared/utils/il2cpp-utils-fields.hpp"
#include "beatsaber-hook/shared/utils/utils.h"
#include "beatsaber-hook/shared/utils/typedefs-string.hpp"
// Completed includes
// Begin forward declares
// Forward declaring namespace: UnityEngine
namespace UnityEngine {
  // Forward declaring type: Material
  class Material;
  // Forward declaring type: Mesh
  class Mesh;
  // Forward declaring type: Renderer
  class Renderer;
  // Forward declaring type: MeshFilter
  class MeshFilter;
  // Skipping declaration: Object because it is already included!
  // Forward declaring type: MeshRenderer
  class MeshRenderer;
  // Forward declaring type: SkinnedMeshRenderer
  class SkinnedMeshRenderer;
}
// Forward declaring namespace: System::Collections::Generic
namespace System::Collections::Generic {
  // Forward declaring type: Dictionary`2<TKey, TValue>
  template<typename TKey, typename TValue>
  class Dictionary_2;
  // Forward declaring type: Stack`1<T>
  template<typename T>
  class Stack_1;
  // Forward declaring type: List`1<T>
  template<typename T>
  class List_1;
}
// Forward declaring namespace: System
namespace System {
  // Forward declaring type: String
  class String;
}
// Forward declaring namespace: Sigtrap::VrTunnellingPro
namespace Sigtrap::VrTunnellingPro {
  // Forward declaring type: TunnellingPresetMobile
  class TunnellingPresetMobile;
}
// Completed forward declares
// Type namespace: Sigtrap.VrTunnellingPro
namespace Sigtrap::VrTunnellingPro {
  // Forward declaring type: TunnellingMobile
  class TunnellingMobile;
}
#include "beatsaber-hook/shared/utils/il2cpp-type-check.hpp"
NEED_NO_BOX(::Sigtrap::VrTunnellingPro::TunnellingMobile);
DEFINE_IL2CPP_ARG_TYPE(::Sigtrap::VrTunnellingPro::TunnellingMobile*, "Sigtrap.VrTunnellingPro", "TunnellingMobile");
// Type namespace: Sigtrap.VrTunnellingPro
namespace Sigtrap::VrTunnellingPro {
  // Size: 0x238
  #pragma pack(push, 1)
  // Autogenerated type: Sigtrap.VrTunnellingPro.TunnellingMobile
  // [TokenAttribute] Offset: FFFFFFFF
  class TunnellingMobile : public ::Sigtrap::VrTunnellingPro::TunnellingBase {
    public:
    public:
    // [TooltipAttribute] Offset: 0xBC4A0
    // public System.Boolean drawSkybox
    // Size: 0x1
    // Offset: 0x1C8
    bool drawSkybox;
    // Field size check
    static_assert(sizeof(bool) == 0x1);
    // [TooltipAttribute] Offset: 0xBD8B0
    // public System.Boolean useMask
    // Size: 0x1
    // Offset: 0x1C9
    bool useMask;
    // Field size check
    static_assert(sizeof(bool) == 0x1);
    // [TooltipAttribute] Offset: 0xBD910
    // public System.Boolean drawBeforeTransparent
    // Size: 0x1
    // Offset: 0x1CA
    bool drawBeforeTransparent;
    // Field size check
    static_assert(sizeof(bool) == 0x1);
    // Padding between fields: drawBeforeTransparent and: stencilReference
    char __padding2[0x1] = {};
    // [TooltipAttribute] Offset: 0xBDA10
    // [RangeAttribute] Offset: 0xBDA10
    // public System.Int32 stencilReference
    // Size: 0x4
    // Offset: 0x1CC
    int stencilReference;
    // Field size check
    static_assert(sizeof(int) == 0x4);
    // [TooltipAttribute] Offset: 0xBDAE0
    // [RangeAttribute] Offset: 0xBDAE0
    // public System.Int32 stencilMask
    // Size: 0x4
    // Offset: 0x1D0
    int stencilMask;
    // Field size check
    static_assert(sizeof(int) == 0x4);
    // [TooltipAttribute] Offset: 0xBDB70
    // [RangeAttribute] Offset: 0xBDB70
    // public System.Single stencilBias
    // Size: 0x4
    // Offset: 0x1D4
    float stencilBias;
    // Field size check
    static_assert(sizeof(float) == 0x4);
    // private System.Int32 _propColor
    // Size: 0x4
    // Offset: 0x1D8
    int propColor;
    // Field size check
    static_assert(sizeof(int) == 0x4);
    // private System.Int32 _propSkybox
    // Size: 0x4
    // Offset: 0x1DC
    int propSkybox;
    // Field size check
    static_assert(sizeof(int) == 0x4);
    // private System.Int32 _propWriteZ
    // Size: 0x4
    // Offset: 0x1E0
    int propWriteZ;
    // Field size check
    static_assert(sizeof(int) == 0x4);
    // private System.Int32 _globPropStencilRef
    // Size: 0x4
    // Offset: 0x1E4
    int globPropStencilRef;
    // Field size check
    static_assert(sizeof(int) == 0x4);
    // private System.Int32 _globPropStencilMask
    // Size: 0x4
    // Offset: 0x1E8
    int globPropStencilMask;
    // Field size check
    static_assert(sizeof(int) == 0x4);
    // private System.Int32 _globPropStencilBias
    // Size: 0x4
    // Offset: 0x1EC
    int globPropStencilBias;
    // Field size check
    static_assert(sizeof(int) == 0x4);
    // private UnityEngine.Material _irisMatOuter
    // Size: 0x8
    // Offset: 0x1F0
    ::UnityEngine::Material* irisMatOuter;
    // Field size check
    static_assert(sizeof(::UnityEngine::Material*) == 0x8);
    // private UnityEngine.Material _irisMatInner
    // Size: 0x8
    // Offset: 0x1F8
    ::UnityEngine::Material* irisMatInner;
    // Field size check
    static_assert(sizeof(::UnityEngine::Material*) == 0x8);
    // private UnityEngine.Mesh _irisMesh
    // Size: 0x8
    // Offset: 0x200
    ::UnityEngine::Mesh* irisMesh;
    // Field size check
    static_assert(sizeof(::UnityEngine::Mesh*) == 0x8);
    // private System.Collections.Generic.Dictionary`2<UnityEngine.Renderer,UnityEngine.MeshFilter> _maskObjects
    // Size: 0x8
    // Offset: 0x208
    ::System::Collections::Generic::Dictionary_2<::UnityEngine::Renderer*, ::UnityEngine::MeshFilter*>* maskObjects;
    // Field size check
    static_assert(sizeof(::System::Collections::Generic::Dictionary_2<::UnityEngine::Renderer*, ::UnityEngine::MeshFilter*>*) == 0x8);
    // private System.Collections.Generic.Stack`1<UnityEngine.Mesh> _skinnedMeshPool
    // Size: 0x8
    // Offset: 0x210
    ::System::Collections::Generic::Stack_1<::UnityEngine::Mesh*>* skinnedMeshPool;
    // Field size check
    static_assert(sizeof(::System::Collections::Generic::Stack_1<::UnityEngine::Mesh*>*) == 0x8);
    // private System.Collections.Generic.Stack`1<UnityEngine.Mesh> _skinnedMeshesRendering
    // Size: 0x8
    // Offset: 0x218
    ::System::Collections::Generic::Stack_1<::UnityEngine::Mesh*>* skinnedMeshesRendering;
    // Field size check
    static_assert(sizeof(::System::Collections::Generic::Stack_1<::UnityEngine::Mesh*>*) == 0x8);
    // private System.Collections.Generic.List`1<UnityEngine.Object> _toDestroy
    // Size: 0x8
    // Offset: 0x220
    ::System::Collections::Generic::List_1<::UnityEngine::Object*>* toDestroy;
    // Field size check
    static_assert(sizeof(::System::Collections::Generic::List_1<::UnityEngine::Object*>*) == 0x8);
    // private System.Collections.Generic.List`1<UnityEngine.MeshRenderer> _tempMeshChildren
    // Size: 0x8
    // Offset: 0x228
    ::System::Collections::Generic::List_1<::UnityEngine::MeshRenderer*>* tempMeshChildren;
    // Field size check
    static_assert(sizeof(::System::Collections::Generic::List_1<::UnityEngine::MeshRenderer*>*) == 0x8);
    // private System.Collections.Generic.List`1<UnityEngine.SkinnedMeshRenderer> _tempSkinnedMeshChildren
    // Size: 0x8
    // Offset: 0x230
    ::System::Collections::Generic::List_1<::UnityEngine::SkinnedMeshRenderer*>* tempSkinnedMeshChildren;
    // Field size check
    static_assert(sizeof(::System::Collections::Generic::List_1<::UnityEngine::SkinnedMeshRenderer*>*) == 0x8);
    public:
    // static field const value: static public System.String GLOBAL_PROP_STENCILREF
    static constexpr const char* GLOBAL_PROP_STENCILREF = "_VRTP_Stencil_Ref";
    // Get static field: static public System.String GLOBAL_PROP_STENCILREF
    static ::StringW _get_GLOBAL_PROP_STENCILREF();
    // Set static field: static public System.String GLOBAL_PROP_STENCILREF
    static void _set_GLOBAL_PROP_STENCILREF(::StringW value);
    // static field const value: static public System.String GLOBAL_PROP_STENCILMASK
    static constexpr const char* GLOBAL_PROP_STENCILMASK = "_VRTP_Stencil_Mask";
    // Get static field: static public System.String GLOBAL_PROP_STENCILMASK
    static ::StringW _get_GLOBAL_PROP_STENCILMASK();
    // Set static field: static public System.String GLOBAL_PROP_STENCILMASK
    static void _set_GLOBAL_PROP_STENCILMASK(::StringW value);
    // static field const value: static public System.String GLOBAL_PROP_STENCILBIAS
    static constexpr const char* GLOBAL_PROP_STENCILBIAS = "_VRTP_Stencil_Bias";
    // Get static field: static public System.String GLOBAL_PROP_STENCILBIAS
    static ::StringW _get_GLOBAL_PROP_STENCILBIAS();
    // Set static field: static public System.String GLOBAL_PROP_STENCILBIAS
    static void _set_GLOBAL_PROP_STENCILBIAS(::StringW value);
    // static field const value: static private System.String PROP_WRITEZ
    static constexpr const char* PROP_WRITEZ = "_WriteZ";
    // Get static field: static private System.String PROP_WRITEZ
    static ::StringW _get_PROP_WRITEZ();
    // Set static field: static private System.String PROP_WRITEZ
    static void _set_PROP_WRITEZ(::StringW value);
    // static field const value: static private System.String PATH_SHADER
    static constexpr const char* PATH_SHADER = "TunnellingVertex";
    // Get static field: static private System.String PATH_SHADER
    static ::StringW _get_PATH_SHADER();
    // Set static field: static private System.String PATH_SHADER
    static void _set_PATH_SHADER(::StringW value);
    // static field const value: static private System.String PATH_STENCILSHADER
    static constexpr const char* PATH_STENCILSHADER = "TunnellingMobileStencil";
    // Get static field: static private System.String PATH_STENCILSHADER
    static ::StringW _get_PATH_STENCILSHADER();
    // Set static field: static private System.String PATH_STENCILSHADER
    static void _set_PATH_STENCILSHADER(::StringW value);
    // static field const value: static private UnityEngine.Rendering.CameraEvent CEVENT_FX
    static constexpr const int CEVENT_FX = 18;
    // Get static field: static private UnityEngine.Rendering.CameraEvent CEVENT_FX
    static ::UnityEngine::Rendering::CameraEvent _get_CEVENT_FX();
    // Set static field: static private UnityEngine.Rendering.CameraEvent CEVENT_FX
    static void _set_CEVENT_FX(::UnityEngine::Rendering::CameraEvent value);
    // static field const value: static private UnityEngine.Rendering.CameraEvent CEVENT_Z
    static constexpr const int CEVENT_Z = 10;
    // Get static field: static private UnityEngine.Rendering.CameraEvent CEVENT_Z
    static ::UnityEngine::Rendering::CameraEvent _get_CEVENT_Z();
    // Set static field: static private UnityEngine.Rendering.CameraEvent CEVENT_Z
    static void _set_CEVENT_Z(::UnityEngine::Rendering::CameraEvent value);
    // static field const value: static private System.Int32 RQUEUE_FIRST
    static constexpr const int RQUEUE_FIRST = 1;
    // Get static field: static private System.Int32 RQUEUE_FIRST
    static int _get_RQUEUE_FIRST();
    // Set static field: static private System.Int32 RQUEUE_FIRST
    static void _set_RQUEUE_FIRST(int value);
    // static field const value: static private System.Int32 RQUEUE_MASK
    static constexpr const int RQUEUE_MASK = 2499;
    // Get static field: static private System.Int32 RQUEUE_MASK
    static int _get_RQUEUE_MASK();
    // Set static field: static private System.Int32 RQUEUE_MASK
    static void _set_RQUEUE_MASK(int value);
    // static field const value: static private System.Int32 RQUEUE_OPAQUE
    static constexpr const int RQUEUE_OPAQUE = 2501;
    // Get static field: static private System.Int32 RQUEUE_OPAQUE
    static int _get_RQUEUE_OPAQUE();
    // Set static field: static private System.Int32 RQUEUE_OPAQUE
    static void _set_RQUEUE_OPAQUE(int value);
    // static field const value: static private System.Int32 RQUEUE_LAST
    static constexpr const int RQUEUE_LAST = 5000;
    // Get static field: static private System.Int32 RQUEUE_LAST
    static int _get_RQUEUE_LAST();
    // Set static field: static private System.Int32 RQUEUE_LAST
    static void _set_RQUEUE_LAST(int value);
    // Get static field: static private Sigtrap.VrTunnellingPro.TunnellingMobile <instance>k__BackingField
    static ::Sigtrap::VrTunnellingPro::TunnellingMobile* _get_$instance$k__BackingField();
    // Set static field: static private Sigtrap.VrTunnellingPro.TunnellingMobile <instance>k__BackingField
    static void _set_$instance$k__BackingField(::Sigtrap::VrTunnellingPro::TunnellingMobile* value);
    // Get static field: static private UnityEngine.Material _stencilMat
    static ::UnityEngine::Material* _get__stencilMat();
    // Set static field: static private UnityEngine.Material _stencilMat
    static void _set__stencilMat(::UnityEngine::Material* value);
    // Get instance field reference: public System.Boolean drawSkybox
    [[deprecated("Use field access instead!")]] bool& dyn_drawSkybox();
    // Get instance field reference: public System.Boolean useMask
    [[deprecated("Use field access instead!")]] bool& dyn_useMask();
    // Get instance field reference: public System.Boolean drawBeforeTransparent
    [[deprecated("Use field access instead!")]] bool& dyn_drawBeforeTransparent();
    // Get instance field reference: public System.Int32 stencilReference
    [[deprecated("Use field access instead!")]] int& dyn_stencilReference();
    // Get instance field reference: public System.Int32 stencilMask
    [[deprecated("Use field access instead!")]] int& dyn_stencilMask();
    // Get instance field reference: public System.Single stencilBias
    [[deprecated("Use field access instead!")]] float& dyn_stencilBias();
    // Get instance field reference: private System.Int32 _propColor
    [[deprecated("Use field access instead!")]] int& dyn__propColor();
    // Get instance field reference: private System.Int32 _propSkybox
    [[deprecated("Use field access instead!")]] int& dyn__propSkybox();
    // Get instance field reference: private System.Int32 _propWriteZ
    [[deprecated("Use field access instead!")]] int& dyn__propWriteZ();
    // Get instance field reference: private System.Int32 _globPropStencilRef
    [[deprecated("Use field access instead!")]] int& dyn__globPropStencilRef();
    // Get instance field reference: private System.Int32 _globPropStencilMask
    [[deprecated("Use field access instead!")]] int& dyn__globPropStencilMask();
    // Get instance field reference: private System.Int32 _globPropStencilBias
    [[deprecated("Use field access instead!")]] int& dyn__globPropStencilBias();
    // Get instance field reference: private UnityEngine.Material _irisMatOuter
    [[deprecated("Use field access instead!")]] ::UnityEngine::Material*& dyn__irisMatOuter();
    // Get instance field reference: private UnityEngine.Material _irisMatInner
    [[deprecated("Use field access instead!")]] ::UnityEngine::Material*& dyn__irisMatInner();
    // Get instance field reference: private UnityEngine.Mesh _irisMesh
    [[deprecated("Use field access instead!")]] ::UnityEngine::Mesh*& dyn__irisMesh();
    // Get instance field reference: private System.Collections.Generic.Dictionary`2<UnityEngine.Renderer,UnityEngine.MeshFilter> _maskObjects
    [[deprecated("Use field access instead!")]] ::System::Collections::Generic::Dictionary_2<::UnityEngine::Renderer*, ::UnityEngine::MeshFilter*>*& dyn__maskObjects();
    // Get instance field reference: private System.Collections.Generic.Stack`1<UnityEngine.Mesh> _skinnedMeshPool
    [[deprecated("Use field access instead!")]] ::System::Collections::Generic::Stack_1<::UnityEngine::Mesh*>*& dyn__skinnedMeshPool();
    // Get instance field reference: private System.Collections.Generic.Stack`1<UnityEngine.Mesh> _skinnedMeshesRendering
    [[deprecated("Use field access instead!")]] ::System::Collections::Generic::Stack_1<::UnityEngine::Mesh*>*& dyn__skinnedMeshesRendering();
    // Get instance field reference: private System.Collections.Generic.List`1<UnityEngine.Object> _toDestroy
    [[deprecated("Use field access instead!")]] ::System::Collections::Generic::List_1<::UnityEngine::Object*>*& dyn__toDestroy();
    // Get instance field reference: private System.Collections.Generic.List`1<UnityEngine.MeshRenderer> _tempMeshChildren
    [[deprecated("Use field access instead!")]] ::System::Collections::Generic::List_1<::UnityEngine::MeshRenderer*>*& dyn__tempMeshChildren();
    // Get instance field reference: private System.Collections.Generic.List`1<UnityEngine.SkinnedMeshRenderer> _tempSkinnedMeshChildren
    [[deprecated("Use field access instead!")]] ::System::Collections::Generic::List_1<::UnityEngine::SkinnedMeshRenderer*>*& dyn__tempSkinnedMeshChildren();
    // static public Sigtrap.VrTunnellingPro.TunnellingMobile get_instance()
    // Offset: 0x6D9610
    static ::Sigtrap::VrTunnellingPro::TunnellingMobile* get_instance();
    // static private System.Void set_instance(Sigtrap.VrTunnellingPro.TunnellingMobile value)
    // Offset: 0x6D9740
    static void set_instance(::Sigtrap::VrTunnellingPro::TunnellingMobile* value);
    // static public UnityEngine.Material get_stencilMat()
    // Offset: 0x6D9670
    static ::UnityEngine::Material* get_stencilMat();
    // public System.Boolean get_irisZRejectionEnabled()
    // Offset: 0x6D9650
    bool get_irisZRejectionEnabled();
    // public System.Void ApplyPreset(Sigtrap.VrTunnellingPro.TunnellingPresetMobile p)
    // Offset: 0x6D7F40
    void ApplyPreset(::Sigtrap::VrTunnellingPro::TunnellingPresetMobile* p);
    // public System.Void AddObjectToMask(UnityEngine.Renderer r, System.Boolean includeChildren)
    // Offset: 0x6D7BD0
    void AddObjectToMask(::UnityEngine::Renderer* r, bool includeChildren);
    // public System.Void RemoveObjectFromMask(UnityEngine.Renderer r, System.Boolean includeChildren)
    // Offset: 0x6D92D0
    void RemoveObjectFromMask(::UnityEngine::Renderer* r, bool includeChildren);
    // private System.Void OnDestroy()
    // Offset: 0x6D8EB0
    void OnDestroy();
    // private System.Void LateUpdate()
    // Offset: 0x6D8630
    void LateUpdate();
    // private System.Void DrawIris(UnityEngine.Material m, System.Int32 submesh, System.Int32 opaqueQueue, System.Int32 camLayer)
    // Offset: 0x6D8310
    void DrawIris(::UnityEngine::Material* m, int submesh, int opaqueQueue, int camLayer);
    // private System.Void OnPreRender()
    // Offset: 0x6D9240
    void OnPreRender();
    // public System.Void .ctor()
    // Offset: 0x6D9490
    // Implemented from: Sigtrap.VrTunnellingPro.TunnellingBase
    // Base method: System.Void TunnellingBase::.ctor()
    template<::il2cpp_utils::CreationType creationType = ::il2cpp_utils::CreationType::Temporary>
    static TunnellingMobile* New_ctor() {
      static auto ___internal__logger = ::Logger::get().WithContext("::Sigtrap::VrTunnellingPro::TunnellingMobile::.ctor");
      return THROW_UNLESS((::il2cpp_utils::New<TunnellingMobile*, creationType>()));
    }
    // protected override System.Void Awake()
    // Offset: 0x6D8000
    // Implemented from: Sigtrap.VrTunnellingPro.TunnellingBase
    // Base method: System.Void TunnellingBase::Awake()
    void Awake();
  }; // Sigtrap.VrTunnellingPro.TunnellingMobile
  #pragma pack(pop)
  static check_size<sizeof(TunnellingMobile), 560 + sizeof(::System::Collections::Generic::List_1<::UnityEngine::SkinnedMeshRenderer*>*)> __Sigtrap_VrTunnellingPro_TunnellingMobileSizeCheck;
  static_assert(sizeof(TunnellingMobile) == 0x238);
}
#include "beatsaber-hook/shared/utils/il2cpp-utils-methods.hpp"
// Writing MetadataGetter for method: Sigtrap::VrTunnellingPro::TunnellingMobile::get_instance
// Il2CppName: get_instance
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<::Sigtrap::VrTunnellingPro::TunnellingMobile* (*)()>(&Sigtrap::VrTunnellingPro::TunnellingMobile::get_instance)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(Sigtrap::VrTunnellingPro::TunnellingMobile*), "get_instance", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: Sigtrap::VrTunnellingPro::TunnellingMobile::set_instance
// Il2CppName: set_instance
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (*)(::Sigtrap::VrTunnellingPro::TunnellingMobile*)>(&Sigtrap::VrTunnellingPro::TunnellingMobile::set_instance)> {
  static const MethodInfo* get() {
    static auto* value = &::il2cpp_utils::GetClassFromName("Sigtrap.VrTunnellingPro", "TunnellingMobile")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(Sigtrap::VrTunnellingPro::TunnellingMobile*), "set_instance", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{value});
  }
};
// Writing MetadataGetter for method: Sigtrap::VrTunnellingPro::TunnellingMobile::get_stencilMat
// Il2CppName: get_stencilMat
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<::UnityEngine::Material* (*)()>(&Sigtrap::VrTunnellingPro::TunnellingMobile::get_stencilMat)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(Sigtrap::VrTunnellingPro::TunnellingMobile*), "get_stencilMat", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: Sigtrap::VrTunnellingPro::TunnellingMobile::get_irisZRejectionEnabled
// Il2CppName: get_irisZRejectionEnabled
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<bool (Sigtrap::VrTunnellingPro::TunnellingMobile::*)()>(&Sigtrap::VrTunnellingPro::TunnellingMobile::get_irisZRejectionEnabled)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(Sigtrap::VrTunnellingPro::TunnellingMobile*), "get_irisZRejectionEnabled", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: Sigtrap::VrTunnellingPro::TunnellingMobile::ApplyPreset
// Il2CppName: ApplyPreset
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (Sigtrap::VrTunnellingPro::TunnellingMobile::*)(::Sigtrap::VrTunnellingPro::TunnellingPresetMobile*)>(&Sigtrap::VrTunnellingPro::TunnellingMobile::ApplyPreset)> {
  static const MethodInfo* get() {
    static auto* p = &::il2cpp_utils::GetClassFromName("Sigtrap.VrTunnellingPro", "TunnellingPresetMobile")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(Sigtrap::VrTunnellingPro::TunnellingMobile*), "ApplyPreset", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{p});
  }
};
// Writing MetadataGetter for method: Sigtrap::VrTunnellingPro::TunnellingMobile::AddObjectToMask
// Il2CppName: AddObjectToMask
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (Sigtrap::VrTunnellingPro::TunnellingMobile::*)(::UnityEngine::Renderer*, bool)>(&Sigtrap::VrTunnellingPro::TunnellingMobile::AddObjectToMask)> {
  static const MethodInfo* get() {
    static auto* r = &::il2cpp_utils::GetClassFromName("UnityEngine", "Renderer")->byval_arg;
    static auto* includeChildren = &::il2cpp_utils::GetClassFromName("System", "Boolean")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(Sigtrap::VrTunnellingPro::TunnellingMobile*), "AddObjectToMask", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{r, includeChildren});
  }
};
// Writing MetadataGetter for method: Sigtrap::VrTunnellingPro::TunnellingMobile::RemoveObjectFromMask
// Il2CppName: RemoveObjectFromMask
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (Sigtrap::VrTunnellingPro::TunnellingMobile::*)(::UnityEngine::Renderer*, bool)>(&Sigtrap::VrTunnellingPro::TunnellingMobile::RemoveObjectFromMask)> {
  static const MethodInfo* get() {
    static auto* r = &::il2cpp_utils::GetClassFromName("UnityEngine", "Renderer")->byval_arg;
    static auto* includeChildren = &::il2cpp_utils::GetClassFromName("System", "Boolean")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(Sigtrap::VrTunnellingPro::TunnellingMobile*), "RemoveObjectFromMask", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{r, includeChildren});
  }
};
// Writing MetadataGetter for method: Sigtrap::VrTunnellingPro::TunnellingMobile::OnDestroy
// Il2CppName: OnDestroy
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (Sigtrap::VrTunnellingPro::TunnellingMobile::*)()>(&Sigtrap::VrTunnellingPro::TunnellingMobile::OnDestroy)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(Sigtrap::VrTunnellingPro::TunnellingMobile*), "OnDestroy", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: Sigtrap::VrTunnellingPro::TunnellingMobile::LateUpdate
// Il2CppName: LateUpdate
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (Sigtrap::VrTunnellingPro::TunnellingMobile::*)()>(&Sigtrap::VrTunnellingPro::TunnellingMobile::LateUpdate)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(Sigtrap::VrTunnellingPro::TunnellingMobile*), "LateUpdate", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: Sigtrap::VrTunnellingPro::TunnellingMobile::DrawIris
// Il2CppName: DrawIris
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (Sigtrap::VrTunnellingPro::TunnellingMobile::*)(::UnityEngine::Material*, int, int, int)>(&Sigtrap::VrTunnellingPro::TunnellingMobile::DrawIris)> {
  static const MethodInfo* get() {
    static auto* m = &::il2cpp_utils::GetClassFromName("UnityEngine", "Material")->byval_arg;
    static auto* submesh = &::il2cpp_utils::GetClassFromName("System", "Int32")->byval_arg;
    static auto* opaqueQueue = &::il2cpp_utils::GetClassFromName("System", "Int32")->byval_arg;
    static auto* camLayer = &::il2cpp_utils::GetClassFromName("System", "Int32")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(Sigtrap::VrTunnellingPro::TunnellingMobile*), "DrawIris", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{m, submesh, opaqueQueue, camLayer});
  }
};
// Writing MetadataGetter for method: Sigtrap::VrTunnellingPro::TunnellingMobile::OnPreRender
// Il2CppName: OnPreRender
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (Sigtrap::VrTunnellingPro::TunnellingMobile::*)()>(&Sigtrap::VrTunnellingPro::TunnellingMobile::OnPreRender)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(Sigtrap::VrTunnellingPro::TunnellingMobile*), "OnPreRender", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: Sigtrap::VrTunnellingPro::TunnellingMobile::New_ctor
// Il2CppName: .ctor
// Cannot get method pointer of value based method overload from template for constructor!
// Try using FindMethod instead!
// Writing MetadataGetter for method: Sigtrap::VrTunnellingPro::TunnellingMobile::Awake
// Il2CppName: Awake
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (Sigtrap::VrTunnellingPro::TunnellingMobile::*)()>(&Sigtrap::VrTunnellingPro::TunnellingMobile::Awake)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(Sigtrap::VrTunnellingPro::TunnellingMobile*), "Awake", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
