// Autogenerated from CppHeaderCreator
// Created by Sc2ad
// =========================================================================
#pragma once
// Begin includes
#include "beatsaber-hook/shared/utils/typedefs.h"
#include "beatsaber-hook/shared/utils/byref.hpp"
// Including type: Sigtrap.VrTunnellingPro.TunnellingPresetBase
#include "Sigtrap/VrTunnellingPro/TunnellingPresetBase.hpp"
// Including type: Sigtrap.VrTunnellingPro.TunnellingBase/Sigtrap.VrTunnellingPro.BackgroundMode
#include "Sigtrap/VrTunnellingPro/TunnellingBase_BackgroundMode.hpp"
// Including type: Sigtrap.VrTunnellingPro.TunnellingBase/Sigtrap.VrTunnellingPro.MSAA
#include "Sigtrap/VrTunnellingPro/TunnellingBase_MSAA.hpp"
// Including type: Sigtrap.VrTunnellingPro.TunnellingBase/Sigtrap.VrTunnellingPro.MaskMode
#include "Sigtrap/VrTunnellingPro/TunnellingBase_MaskMode.hpp"
// Including type: Sigtrap.VrTunnellingPro.TunnellingImageBase/Sigtrap.VrTunnellingPro.BlurKernel
#include "Sigtrap/VrTunnellingPro/TunnellingImageBase.hpp"
// Including type: Sigtrap.VrTunnellingPro.TunnellingImageBase/Sigtrap.VrTunnellingPro.CounterVelocityMode
// Already included the same include: Sigtrap/VrTunnellingPro/TunnellingImageBase.hpp
#include "beatsaber-hook/shared/utils/il2cpp-utils-methods.hpp"
#include "beatsaber-hook/shared/utils/il2cpp-utils-properties.hpp"
#include "beatsaber-hook/shared/utils/il2cpp-utils-fields.hpp"
#include "beatsaber-hook/shared/utils/utils.h"
// Completed includes
// Type namespace: Sigtrap.VrTunnellingPro
namespace Sigtrap::VrTunnellingPro {
  // Forward declaring type: TunnellingPreset
  class TunnellingPreset;
}
#include "beatsaber-hook/shared/utils/il2cpp-type-check.hpp"
NEED_NO_BOX(::Sigtrap::VrTunnellingPro::TunnellingPreset);
DEFINE_IL2CPP_ARG_TYPE(::Sigtrap::VrTunnellingPro::TunnellingPreset*, "Sigtrap.VrTunnellingPro", "TunnellingPreset");
// Type namespace: Sigtrap.VrTunnellingPro
namespace Sigtrap::VrTunnellingPro {
  // Size: 0x13F
  #pragma pack(push, 1)
  // Autogenerated type: Sigtrap.VrTunnellingPro.TunnellingPreset
  // [TokenAttribute] Offset: FFFFFFFF
  // [CreateAssetMenuAttribute] Offset: BDD60
  class TunnellingPreset : public ::Sigtrap::VrTunnellingPro::TunnellingPresetBase {
    public:
    // Writing base type padding for base size: 0xAD to desired offset: 0xB0
    char ___base_padding[0x3] = {};
    public:
    // [RangeAttribute] Offset: 0xBDE10
    // private System.Single _effectOverlay
    // Size: 0x4
    // Offset: 0xB0
    float effectOverlay;
    // Field size check
    static_assert(sizeof(float) == 0x4);
    // private System.Boolean _overrideEffectOverlay
    // Size: 0x1
    // Offset: 0xB4
    bool overrideEffectOverlay;
    // Field size check
    static_assert(sizeof(bool) == 0x1);
    // Padding between fields: overrideEffectOverlay and: backgroundMode
    char __padding1[0x3] = {};
    // private Sigtrap.VrTunnellingPro.TunnellingBase/Sigtrap.VrTunnellingPro.BackgroundMode _backgroundMode
    // Size: 0x4
    // Offset: 0xB8
    ::Sigtrap::VrTunnellingPro::TunnellingBase::BackgroundMode backgroundMode;
    // Field size check
    static_assert(sizeof(::Sigtrap::VrTunnellingPro::TunnellingBase::BackgroundMode) == 0x4);
    // private System.Boolean _overrideBackgroundMode
    // Size: 0x1
    // Offset: 0xBC
    bool overrideBackgroundMode;
    // Field size check
    static_assert(sizeof(bool) == 0x1);
    // Padding between fields: overrideBackgroundMode and: cageDownsample
    char __padding3[0x3] = {};
    // [RangeAttribute] Offset: 0xBDF90
    // private System.Int32 _cageDownsample
    // Size: 0x4
    // Offset: 0xC0
    int cageDownsample;
    // Field size check
    static_assert(sizeof(int) == 0x4);
    // private System.Boolean _overrideCageDownsample
    // Size: 0x1
    // Offset: 0xC4
    bool overrideCageDownsample;
    // Field size check
    static_assert(sizeof(bool) == 0x1);
    // Padding between fields: overrideCageDownsample and: cageAntiAliasing
    char __padding5[0x3] = {};
    // private Sigtrap.VrTunnellingPro.TunnellingBase/Sigtrap.VrTunnellingPro.MSAA _cageAntiAliasing
    // Size: 0x4
    // Offset: 0xC8
    ::Sigtrap::VrTunnellingPro::TunnellingBase::MSAA cageAntiAliasing;
    // Field size check
    static_assert(sizeof(::Sigtrap::VrTunnellingPro::TunnellingBase::MSAA) == 0x4);
    // private System.Boolean _overrideCageAntiAliasing
    // Size: 0x1
    // Offset: 0xCC
    bool overrideCageAntiAliasing;
    // Field size check
    static_assert(sizeof(bool) == 0x1);
    // private System.Boolean _cageUpdateEveryFrame
    // Size: 0x1
    // Offset: 0xCD
    bool cageUpdateEveryFrame;
    // Field size check
    static_assert(sizeof(bool) == 0x1);
    // private System.Boolean _overrideCageUpdateEveryFrame
    // Size: 0x1
    // Offset: 0xCE
    bool overrideCageUpdateEveryFrame;
    // Field size check
    static_assert(sizeof(bool) == 0x1);
    // Padding between fields: overrideCageUpdateEveryFrame and: cageFogDensity
    char __padding9[0x1] = {};
    // [RangeAttribute] Offset: 0xBE180
    // private System.Single _cageFogDensity
    // Size: 0x4
    // Offset: 0xD0
    float cageFogDensity;
    // Field size check
    static_assert(sizeof(float) == 0x4);
    // private System.Boolean _overrideCageFogDensity
    // Size: 0x1
    // Offset: 0xD4
    bool overrideCageFogDensity;
    // Field size check
    static_assert(sizeof(bool) == 0x1);
    // Padding between fields: overrideCageFogDensity and: cageFogPower
    char __padding11[0x3] = {};
    // [RangeAttribute] Offset: 0xBE2C0
    // private System.Single _cageFogPower
    // Size: 0x4
    // Offset: 0xD8
    float cageFogPower;
    // Field size check
    static_assert(sizeof(float) == 0x4);
    // private System.Boolean _overrideCageFogPower
    // Size: 0x1
    // Offset: 0xDC
    bool overrideCageFogPower;
    // Field size check
    static_assert(sizeof(bool) == 0x1);
    // Padding between fields: overrideCageFogPower and: cageFogBlend
    char __padding13[0x3] = {};
    // [RangeAttribute] Offset: 0xBDE10
    // private System.Single _cageFogBlend
    // Size: 0x4
    // Offset: 0xE0
    float cageFogBlend;
    // Field size check
    static_assert(sizeof(float) == 0x4);
    // private System.Boolean _overrideCageFogBlend
    // Size: 0x1
    // Offset: 0xE4
    bool overrideCageFogBlend;
    // Field size check
    static_assert(sizeof(bool) == 0x1);
    // Padding between fields: overrideCageFogBlend and: maskMode
    char __padding15[0x3] = {};
    // private Sigtrap.VrTunnellingPro.TunnellingBase/Sigtrap.VrTunnellingPro.MaskMode _maskMode
    // Size: 0x4
    // Offset: 0xE8
    ::Sigtrap::VrTunnellingPro::TunnellingBase::MaskMode maskMode;
    // Field size check
    static_assert(sizeof(::Sigtrap::VrTunnellingPro::TunnellingBase::MaskMode) == 0x4);
    // private System.Boolean _overrideMaskMode
    // Size: 0x1
    // Offset: 0xEC
    bool overrideMaskMode;
    // Field size check
    static_assert(sizeof(bool) == 0x1);
    // Padding between fields: overrideMaskMode and: blurDownsample
    char __padding17[0x3] = {};
    // [RangeAttribute] Offset: 0xBE4A0
    // private System.Int32 _blurDownsample
    // Size: 0x4
    // Offset: 0xF0
    int blurDownsample;
    // Field size check
    static_assert(sizeof(int) == 0x4);
    // private System.Boolean _overrideBlurDownsample
    // Size: 0x1
    // Offset: 0xF4
    bool overrideBlurDownsample;
    // Field size check
    static_assert(sizeof(bool) == 0x1);
    // Padding between fields: overrideBlurDownsample and: blurDistance
    char __padding19[0x3] = {};
    // [RangeAttribute] Offset: 0xBE2C0
    // private System.Single _blurDistance
    // Size: 0x4
    // Offset: 0xF8
    float blurDistance;
    // Field size check
    static_assert(sizeof(float) == 0x4);
    // private System.Boolean _overrideBlurDistance
    // Size: 0x1
    // Offset: 0xFC
    bool overrideBlurDistance;
    // Field size check
    static_assert(sizeof(bool) == 0x1);
    // Padding between fields: overrideBlurDistance and: blurPasses
    char __padding21[0x3] = {};
    // [RangeAttribute] Offset: 0xBE2C0
    // private System.Int32 _blurPasses
    // Size: 0x4
    // Offset: 0x100
    int blurPasses;
    // Field size check
    static_assert(sizeof(int) == 0x4);
    // private System.Boolean _overrideBlurPasses
    // Size: 0x1
    // Offset: 0x104
    bool overrideBlurPasses;
    // Field size check
    static_assert(sizeof(bool) == 0x1);
    // Padding between fields: overrideBlurPasses and: blurSamples
    char __padding23[0x3] = {};
    // private Sigtrap.VrTunnellingPro.TunnellingImageBase/Sigtrap.VrTunnellingPro.BlurKernel _blurSamples
    // Size: 0x4
    // Offset: 0x108
    ::Sigtrap::VrTunnellingPro::TunnellingImageBase::BlurKernel blurSamples;
    // Field size check
    static_assert(sizeof(::Sigtrap::VrTunnellingPro::TunnellingImageBase::BlurKernel) == 0x4);
    // private System.Boolean _overrideBlurSamples
    // Size: 0x1
    // Offset: 0x10C
    bool overrideBlurSamples;
    // Field size check
    static_assert(sizeof(bool) == 0x1);
    // Padding between fields: overrideBlurSamples and: counterVelocityMode
    char __padding25[0x3] = {};
    // private Sigtrap.VrTunnellingPro.TunnellingImageBase/Sigtrap.VrTunnellingPro.CounterVelocityMode _counterVelocityMode
    // Size: 0x4
    // Offset: 0x110
    ::Sigtrap::VrTunnellingPro::TunnellingImageBase::CounterVelocityMode counterVelocityMode;
    // Field size check
    static_assert(sizeof(::Sigtrap::VrTunnellingPro::TunnellingImageBase::CounterVelocityMode) == 0x4);
    // private System.Boolean _overrideCounterVelocityMode
    // Size: 0x1
    // Offset: 0x114
    bool overrideCounterVelocityMode;
    // Field size check
    static_assert(sizeof(bool) == 0x1);
    // Padding between fields: overrideCounterVelocityMode and: counterVelocityResetDistance
    char __padding27[0x3] = {};
    // private System.Single _counterVelocityResetDistance
    // Size: 0x4
    // Offset: 0x118
    float counterVelocityResetDistance;
    // Field size check
    static_assert(sizeof(float) == 0x4);
    // private System.Boolean _overrideCounterVelocityResetDistance
    // Size: 0x1
    // Offset: 0x11C
    bool overrideCounterVelocityResetDistance;
    // Field size check
    static_assert(sizeof(bool) == 0x1);
    // Padding between fields: overrideCounterVelocityResetDistance and: counterVelocityResetTime
    char __padding29[0x3] = {};
    // private System.Single _counterVelocityResetTime
    // Size: 0x4
    // Offset: 0x120
    float counterVelocityResetTime;
    // Field size check
    static_assert(sizeof(float) == 0x4);
    // private System.Boolean _overrideCounterVelocityResetTime
    // Size: 0x1
    // Offset: 0x124
    bool overrideCounterVelocityResetTime;
    // Field size check
    static_assert(sizeof(bool) == 0x1);
    // Padding between fields: overrideCounterVelocityResetTime and: counterVelocityStrength
    char __padding31[0x3] = {};
    // [RangeAttribute] Offset: 0xBDF90
    // private System.Single _counterVelocityStrength
    // Size: 0x4
    // Offset: 0x128
    float counterVelocityStrength;
    // Field size check
    static_assert(sizeof(float) == 0x4);
    // private System.Boolean _overrideCounterVelocityStrength
    // Size: 0x1
    // Offset: 0x12C
    bool overrideCounterVelocityStrength;
    // Field size check
    static_assert(sizeof(bool) == 0x1);
    // Padding between fields: overrideCounterVelocityStrength and: counterVelocityPerAxis
    char __padding33[0x3] = {};
    // private UnityEngine.Vector3 _counterVelocityPerAxis
    // Size: 0xC
    // Offset: 0x130
    ::UnityEngine::Vector3 counterVelocityPerAxis;
    // Field size check
    static_assert(sizeof(::UnityEngine::Vector3) == 0xC);
    // private System.Boolean _overrideCounterVelocityPerAxis
    // Size: 0x1
    // Offset: 0x13C
    bool overrideCounterVelocityPerAxis;
    // Field size check
    static_assert(sizeof(bool) == 0x1);
    // private System.Boolean _irisZRejection
    // Size: 0x1
    // Offset: 0x13D
    bool irisZRejection;
    // Field size check
    static_assert(sizeof(bool) == 0x1);
    // private System.Boolean _overrideIrisZRejection
    // Size: 0x1
    // Offset: 0x13E
    bool overrideIrisZRejection;
    // Field size check
    static_assert(sizeof(bool) == 0x1);
    public:
    // Get instance field reference: private System.Single _effectOverlay
    [[deprecated("Use field access instead!")]] float& dyn__effectOverlay();
    // Get instance field reference: private System.Boolean _overrideEffectOverlay
    [[deprecated("Use field access instead!")]] bool& dyn__overrideEffectOverlay();
    // Get instance field reference: private Sigtrap.VrTunnellingPro.TunnellingBase/Sigtrap.VrTunnellingPro.BackgroundMode _backgroundMode
    [[deprecated("Use field access instead!")]] ::Sigtrap::VrTunnellingPro::TunnellingBase::BackgroundMode& dyn__backgroundMode();
    // Get instance field reference: private System.Boolean _overrideBackgroundMode
    [[deprecated("Use field access instead!")]] bool& dyn__overrideBackgroundMode();
    // Get instance field reference: private System.Int32 _cageDownsample
    [[deprecated("Use field access instead!")]] int& dyn__cageDownsample();
    // Get instance field reference: private System.Boolean _overrideCageDownsample
    [[deprecated("Use field access instead!")]] bool& dyn__overrideCageDownsample();
    // Get instance field reference: private Sigtrap.VrTunnellingPro.TunnellingBase/Sigtrap.VrTunnellingPro.MSAA _cageAntiAliasing
    [[deprecated("Use field access instead!")]] ::Sigtrap::VrTunnellingPro::TunnellingBase::MSAA& dyn__cageAntiAliasing();
    // Get instance field reference: private System.Boolean _overrideCageAntiAliasing
    [[deprecated("Use field access instead!")]] bool& dyn__overrideCageAntiAliasing();
    // Get instance field reference: private System.Boolean _cageUpdateEveryFrame
    [[deprecated("Use field access instead!")]] bool& dyn__cageUpdateEveryFrame();
    // Get instance field reference: private System.Boolean _overrideCageUpdateEveryFrame
    [[deprecated("Use field access instead!")]] bool& dyn__overrideCageUpdateEveryFrame();
    // Get instance field reference: private System.Single _cageFogDensity
    [[deprecated("Use field access instead!")]] float& dyn__cageFogDensity();
    // Get instance field reference: private System.Boolean _overrideCageFogDensity
    [[deprecated("Use field access instead!")]] bool& dyn__overrideCageFogDensity();
    // Get instance field reference: private System.Single _cageFogPower
    [[deprecated("Use field access instead!")]] float& dyn__cageFogPower();
    // Get instance field reference: private System.Boolean _overrideCageFogPower
    [[deprecated("Use field access instead!")]] bool& dyn__overrideCageFogPower();
    // Get instance field reference: private System.Single _cageFogBlend
    [[deprecated("Use field access instead!")]] float& dyn__cageFogBlend();
    // Get instance field reference: private System.Boolean _overrideCageFogBlend
    [[deprecated("Use field access instead!")]] bool& dyn__overrideCageFogBlend();
    // Get instance field reference: private Sigtrap.VrTunnellingPro.TunnellingBase/Sigtrap.VrTunnellingPro.MaskMode _maskMode
    [[deprecated("Use field access instead!")]] ::Sigtrap::VrTunnellingPro::TunnellingBase::MaskMode& dyn__maskMode();
    // Get instance field reference: private System.Boolean _overrideMaskMode
    [[deprecated("Use field access instead!")]] bool& dyn__overrideMaskMode();
    // Get instance field reference: private System.Int32 _blurDownsample
    [[deprecated("Use field access instead!")]] int& dyn__blurDownsample();
    // Get instance field reference: private System.Boolean _overrideBlurDownsample
    [[deprecated("Use field access instead!")]] bool& dyn__overrideBlurDownsample();
    // Get instance field reference: private System.Single _blurDistance
    [[deprecated("Use field access instead!")]] float& dyn__blurDistance();
    // Get instance field reference: private System.Boolean _overrideBlurDistance
    [[deprecated("Use field access instead!")]] bool& dyn__overrideBlurDistance();
    // Get instance field reference: private System.Int32 _blurPasses
    [[deprecated("Use field access instead!")]] int& dyn__blurPasses();
    // Get instance field reference: private System.Boolean _overrideBlurPasses
    [[deprecated("Use field access instead!")]] bool& dyn__overrideBlurPasses();
    // Get instance field reference: private Sigtrap.VrTunnellingPro.TunnellingImageBase/Sigtrap.VrTunnellingPro.BlurKernel _blurSamples
    [[deprecated("Use field access instead!")]] ::Sigtrap::VrTunnellingPro::TunnellingImageBase::BlurKernel& dyn__blurSamples();
    // Get instance field reference: private System.Boolean _overrideBlurSamples
    [[deprecated("Use field access instead!")]] bool& dyn__overrideBlurSamples();
    // Get instance field reference: private Sigtrap.VrTunnellingPro.TunnellingImageBase/Sigtrap.VrTunnellingPro.CounterVelocityMode _counterVelocityMode
    [[deprecated("Use field access instead!")]] ::Sigtrap::VrTunnellingPro::TunnellingImageBase::CounterVelocityMode& dyn__counterVelocityMode();
    // Get instance field reference: private System.Boolean _overrideCounterVelocityMode
    [[deprecated("Use field access instead!")]] bool& dyn__overrideCounterVelocityMode();
    // Get instance field reference: private System.Single _counterVelocityResetDistance
    [[deprecated("Use field access instead!")]] float& dyn__counterVelocityResetDistance();
    // Get instance field reference: private System.Boolean _overrideCounterVelocityResetDistance
    [[deprecated("Use field access instead!")]] bool& dyn__overrideCounterVelocityResetDistance();
    // Get instance field reference: private System.Single _counterVelocityResetTime
    [[deprecated("Use field access instead!")]] float& dyn__counterVelocityResetTime();
    // Get instance field reference: private System.Boolean _overrideCounterVelocityResetTime
    [[deprecated("Use field access instead!")]] bool& dyn__overrideCounterVelocityResetTime();
    // Get instance field reference: private System.Single _counterVelocityStrength
    [[deprecated("Use field access instead!")]] float& dyn__counterVelocityStrength();
    // Get instance field reference: private System.Boolean _overrideCounterVelocityStrength
    [[deprecated("Use field access instead!")]] bool& dyn__overrideCounterVelocityStrength();
    // Get instance field reference: private UnityEngine.Vector3 _counterVelocityPerAxis
    [[deprecated("Use field access instead!")]] ::UnityEngine::Vector3& dyn__counterVelocityPerAxis();
    // Get instance field reference: private System.Boolean _overrideCounterVelocityPerAxis
    [[deprecated("Use field access instead!")]] bool& dyn__overrideCounterVelocityPerAxis();
    // Get instance field reference: private System.Boolean _irisZRejection
    [[deprecated("Use field access instead!")]] bool& dyn__irisZRejection();
    // Get instance field reference: private System.Boolean _overrideIrisZRejection
    [[deprecated("Use field access instead!")]] bool& dyn__overrideIrisZRejection();
    // public System.Single get_effectOverlay()
    // Offset: 0x307C20
    float get_effectOverlay();
    // public System.Boolean get_overrideEffectOverlay()
    // Offset: 0x307C30
    bool get_overrideEffectOverlay();
    // public Sigtrap.VrTunnellingPro.TunnellingBase/Sigtrap.VrTunnellingPro.BackgroundMode get_backgroundMode()
    // Offset: 0x3F2360
    ::Sigtrap::VrTunnellingPro::TunnellingBase::BackgroundMode get_backgroundMode();
    // public System.Boolean get_overrideBackgroundMode()
    // Offset: 0x6D9CD0
    bool get_overrideBackgroundMode();
    // public System.Int32 get_cageDownsample()
    // Offset: 0x3F26C0
    int get_cageDownsample();
    // public System.Boolean get_overrideCageDownsample()
    // Offset: 0x6D9D30
    bool get_overrideCageDownsample();
    // public Sigtrap.VrTunnellingPro.TunnellingBase/Sigtrap.VrTunnellingPro.MSAA get_cageAntiAliasing()
    // Offset: 0x3F2620
    ::Sigtrap::VrTunnellingPro::TunnellingBase::MSAA get_cageAntiAliasing();
    // public System.Boolean get_overrideCageAntiAliasing()
    // Offset: 0x6D9D20
    bool get_overrideCageAntiAliasing();
    // public System.Boolean get_cageUpdateEveryFrame()
    // Offset: 0x6D9C80
    bool get_cageUpdateEveryFrame();
    // public System.Boolean get_overrideCageUpdateEveryFrame()
    // Offset: 0x6D9D70
    bool get_overrideCageUpdateEveryFrame();
    // public System.Single get_cageFogDensity()
    // Offset: 0x307C10
    float get_cageFogDensity();
    // public System.Boolean get_overrideCageFogDensity()
    // Offset: 0x6D9D50
    bool get_overrideCageFogDensity();
    // public System.Single get_cageFogPower()
    // Offset: 0x2FFDF0
    float get_cageFogPower();
    // public System.Boolean get_overrideCageFogPower()
    // Offset: 0x6D9D60
    bool get_overrideCageFogPower();
    // public System.Single get_cageFogBlend()
    // Offset: 0x2FFE20
    float get_cageFogBlend();
    // public System.Boolean get_overrideCageFogBlend()
    // Offset: 0x6D9D40
    bool get_overrideCageFogBlend();
    // public Sigtrap.VrTunnellingPro.TunnellingBase/Sigtrap.VrTunnellingPro.MaskMode get_maskMode()
    // Offset: 0x6D9CC0
    ::Sigtrap::VrTunnellingPro::TunnellingBase::MaskMode get_maskMode();
    // public System.Boolean get_overrideMaskMode()
    // Offset: 0x6D9DE0
    bool get_overrideMaskMode();
    // public System.Int32 get_blurDownsample()
    // Offset: 0x6D9C70
    int get_blurDownsample();
    // public System.Boolean get_overrideBlurDownsample()
    // Offset: 0x6D9CF0
    bool get_overrideBlurDownsample();
    // public System.Single get_blurDistance()
    // Offset: 0x4C0070
    float get_blurDistance();
    // public System.Boolean get_overrideBlurDistance()
    // Offset: 0x6D9CE0
    bool get_overrideBlurDistance();
    // public System.Int32 get_blurPasses()
    // Offset: 0x292770
    int get_blurPasses();
    // public System.Boolean get_overrideBlurPasses()
    // Offset: 0x6D9D00
    bool get_overrideBlurPasses();
    // public Sigtrap.VrTunnellingPro.TunnellingImageBase/Sigtrap.VrTunnellingPro.BlurKernel get_blurSamples()
    // Offset: 0x4E2E50
    ::Sigtrap::VrTunnellingPro::TunnellingImageBase::BlurKernel get_blurSamples();
    // public System.Boolean get_overrideBlurSamples()
    // Offset: 0x6D9D10
    bool get_overrideBlurSamples();
    // public Sigtrap.VrTunnellingPro.TunnellingImageBase/Sigtrap.VrTunnellingPro.CounterVelocityMode get_counterVelocityMode()
    // Offset: 0x2B46C0
    ::Sigtrap::VrTunnellingPro::TunnellingImageBase::CounterVelocityMode get_counterVelocityMode();
    // public System.Boolean get_overrideCounterVelocityMode()
    // Offset: 0x6D9D80
    bool get_overrideCounterVelocityMode();
    // public System.Single get_counterVelocityResetDistance()
    // Offset: 0x31C680
    float get_counterVelocityResetDistance();
    // public System.Boolean get_overrideCounterVelocityResetDistance()
    // Offset: 0x6D9DA0
    bool get_overrideCounterVelocityResetDistance();
    // public System.Single get_counterVelocityResetTime()
    // Offset: 0x602DB0
    float get_counterVelocityResetTime();
    // public System.Boolean get_overrideCounterVelocityResetTime()
    // Offset: 0x6D9DB0
    bool get_overrideCounterVelocityResetTime();
    // public System.Single get_counterVelocityStrength()
    // Offset: 0x603070
    float get_counterVelocityStrength();
    // public System.Boolean get_overrideCounterVelocityStrength()
    // Offset: 0x6D9DC0
    bool get_overrideCounterVelocityStrength();
    // public UnityEngine.Vector3 get_counterVelocityPerAxis()
    // Offset: 0x6D9C90
    ::UnityEngine::Vector3 get_counterVelocityPerAxis();
    // public System.Boolean get_overrideCounterVelocityPerAxis()
    // Offset: 0x6D9D90
    bool get_overrideCounterVelocityPerAxis();
    // public System.Boolean get_irisZRejection()
    // Offset: 0x6D9CB0
    bool get_irisZRejection();
    // public System.Boolean get_overrideIrisZRejection()
    // Offset: 0x6D9DD0
    bool get_overrideIrisZRejection();
    // public System.Void .ctor()
    // Offset: 0x6D9B30
    // Implemented from: Sigtrap.VrTunnellingPro.TunnellingPresetBase
    // Base method: System.Void TunnellingPresetBase::.ctor()
    template<::il2cpp_utils::CreationType creationType = ::il2cpp_utils::CreationType::Temporary>
    static TunnellingPreset* New_ctor() {
      static auto ___internal__logger = ::Logger::get().WithContext("::Sigtrap::VrTunnellingPro::TunnellingPreset::.ctor");
      return THROW_UNLESS((::il2cpp_utils::New<TunnellingPreset*, creationType>()));
    }
  }; // Sigtrap.VrTunnellingPro.TunnellingPreset
  #pragma pack(pop)
  static check_size<sizeof(TunnellingPreset), 318 + sizeof(bool)> __Sigtrap_VrTunnellingPro_TunnellingPresetSizeCheck;
  static_assert(sizeof(TunnellingPreset) == 0x13F);
}
#include "beatsaber-hook/shared/utils/il2cpp-utils-methods.hpp"
// Writing MetadataGetter for method: Sigtrap::VrTunnellingPro::TunnellingPreset::get_effectOverlay
// Il2CppName: get_effectOverlay
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<float (Sigtrap::VrTunnellingPro::TunnellingPreset::*)()>(&Sigtrap::VrTunnellingPro::TunnellingPreset::get_effectOverlay)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(Sigtrap::VrTunnellingPro::TunnellingPreset*), "get_effectOverlay", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: Sigtrap::VrTunnellingPro::TunnellingPreset::get_overrideEffectOverlay
// Il2CppName: get_overrideEffectOverlay
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<bool (Sigtrap::VrTunnellingPro::TunnellingPreset::*)()>(&Sigtrap::VrTunnellingPro::TunnellingPreset::get_overrideEffectOverlay)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(Sigtrap::VrTunnellingPro::TunnellingPreset*), "get_overrideEffectOverlay", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: Sigtrap::VrTunnellingPro::TunnellingPreset::get_backgroundMode
// Il2CppName: get_backgroundMode
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<::Sigtrap::VrTunnellingPro::TunnellingBase::BackgroundMode (Sigtrap::VrTunnellingPro::TunnellingPreset::*)()>(&Sigtrap::VrTunnellingPro::TunnellingPreset::get_backgroundMode)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(Sigtrap::VrTunnellingPro::TunnellingPreset*), "get_backgroundMode", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: Sigtrap::VrTunnellingPro::TunnellingPreset::get_overrideBackgroundMode
// Il2CppName: get_overrideBackgroundMode
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<bool (Sigtrap::VrTunnellingPro::TunnellingPreset::*)()>(&Sigtrap::VrTunnellingPro::TunnellingPreset::get_overrideBackgroundMode)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(Sigtrap::VrTunnellingPro::TunnellingPreset*), "get_overrideBackgroundMode", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: Sigtrap::VrTunnellingPro::TunnellingPreset::get_cageDownsample
// Il2CppName: get_cageDownsample
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<int (Sigtrap::VrTunnellingPro::TunnellingPreset::*)()>(&Sigtrap::VrTunnellingPro::TunnellingPreset::get_cageDownsample)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(Sigtrap::VrTunnellingPro::TunnellingPreset*), "get_cageDownsample", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: Sigtrap::VrTunnellingPro::TunnellingPreset::get_overrideCageDownsample
// Il2CppName: get_overrideCageDownsample
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<bool (Sigtrap::VrTunnellingPro::TunnellingPreset::*)()>(&Sigtrap::VrTunnellingPro::TunnellingPreset::get_overrideCageDownsample)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(Sigtrap::VrTunnellingPro::TunnellingPreset*), "get_overrideCageDownsample", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: Sigtrap::VrTunnellingPro::TunnellingPreset::get_cageAntiAliasing
// Il2CppName: get_cageAntiAliasing
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<::Sigtrap::VrTunnellingPro::TunnellingBase::MSAA (Sigtrap::VrTunnellingPro::TunnellingPreset::*)()>(&Sigtrap::VrTunnellingPro::TunnellingPreset::get_cageAntiAliasing)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(Sigtrap::VrTunnellingPro::TunnellingPreset*), "get_cageAntiAliasing", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: Sigtrap::VrTunnellingPro::TunnellingPreset::get_overrideCageAntiAliasing
// Il2CppName: get_overrideCageAntiAliasing
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<bool (Sigtrap::VrTunnellingPro::TunnellingPreset::*)()>(&Sigtrap::VrTunnellingPro::TunnellingPreset::get_overrideCageAntiAliasing)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(Sigtrap::VrTunnellingPro::TunnellingPreset*), "get_overrideCageAntiAliasing", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: Sigtrap::VrTunnellingPro::TunnellingPreset::get_cageUpdateEveryFrame
// Il2CppName: get_cageUpdateEveryFrame
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<bool (Sigtrap::VrTunnellingPro::TunnellingPreset::*)()>(&Sigtrap::VrTunnellingPro::TunnellingPreset::get_cageUpdateEveryFrame)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(Sigtrap::VrTunnellingPro::TunnellingPreset*), "get_cageUpdateEveryFrame", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: Sigtrap::VrTunnellingPro::TunnellingPreset::get_overrideCageUpdateEveryFrame
// Il2CppName: get_overrideCageUpdateEveryFrame
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<bool (Sigtrap::VrTunnellingPro::TunnellingPreset::*)()>(&Sigtrap::VrTunnellingPro::TunnellingPreset::get_overrideCageUpdateEveryFrame)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(Sigtrap::VrTunnellingPro::TunnellingPreset*), "get_overrideCageUpdateEveryFrame", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: Sigtrap::VrTunnellingPro::TunnellingPreset::get_cageFogDensity
// Il2CppName: get_cageFogDensity
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<float (Sigtrap::VrTunnellingPro::TunnellingPreset::*)()>(&Sigtrap::VrTunnellingPro::TunnellingPreset::get_cageFogDensity)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(Sigtrap::VrTunnellingPro::TunnellingPreset*), "get_cageFogDensity", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: Sigtrap::VrTunnellingPro::TunnellingPreset::get_overrideCageFogDensity
// Il2CppName: get_overrideCageFogDensity
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<bool (Sigtrap::VrTunnellingPro::TunnellingPreset::*)()>(&Sigtrap::VrTunnellingPro::TunnellingPreset::get_overrideCageFogDensity)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(Sigtrap::VrTunnellingPro::TunnellingPreset*), "get_overrideCageFogDensity", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: Sigtrap::VrTunnellingPro::TunnellingPreset::get_cageFogPower
// Il2CppName: get_cageFogPower
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<float (Sigtrap::VrTunnellingPro::TunnellingPreset::*)()>(&Sigtrap::VrTunnellingPro::TunnellingPreset::get_cageFogPower)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(Sigtrap::VrTunnellingPro::TunnellingPreset*), "get_cageFogPower", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: Sigtrap::VrTunnellingPro::TunnellingPreset::get_overrideCageFogPower
// Il2CppName: get_overrideCageFogPower
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<bool (Sigtrap::VrTunnellingPro::TunnellingPreset::*)()>(&Sigtrap::VrTunnellingPro::TunnellingPreset::get_overrideCageFogPower)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(Sigtrap::VrTunnellingPro::TunnellingPreset*), "get_overrideCageFogPower", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: Sigtrap::VrTunnellingPro::TunnellingPreset::get_cageFogBlend
// Il2CppName: get_cageFogBlend
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<float (Sigtrap::VrTunnellingPro::TunnellingPreset::*)()>(&Sigtrap::VrTunnellingPro::TunnellingPreset::get_cageFogBlend)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(Sigtrap::VrTunnellingPro::TunnellingPreset*), "get_cageFogBlend", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: Sigtrap::VrTunnellingPro::TunnellingPreset::get_overrideCageFogBlend
// Il2CppName: get_overrideCageFogBlend
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<bool (Sigtrap::VrTunnellingPro::TunnellingPreset::*)()>(&Sigtrap::VrTunnellingPro::TunnellingPreset::get_overrideCageFogBlend)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(Sigtrap::VrTunnellingPro::TunnellingPreset*), "get_overrideCageFogBlend", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: Sigtrap::VrTunnellingPro::TunnellingPreset::get_maskMode
// Il2CppName: get_maskMode
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<::Sigtrap::VrTunnellingPro::TunnellingBase::MaskMode (Sigtrap::VrTunnellingPro::TunnellingPreset::*)()>(&Sigtrap::VrTunnellingPro::TunnellingPreset::get_maskMode)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(Sigtrap::VrTunnellingPro::TunnellingPreset*), "get_maskMode", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: Sigtrap::VrTunnellingPro::TunnellingPreset::get_overrideMaskMode
// Il2CppName: get_overrideMaskMode
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<bool (Sigtrap::VrTunnellingPro::TunnellingPreset::*)()>(&Sigtrap::VrTunnellingPro::TunnellingPreset::get_overrideMaskMode)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(Sigtrap::VrTunnellingPro::TunnellingPreset*), "get_overrideMaskMode", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: Sigtrap::VrTunnellingPro::TunnellingPreset::get_blurDownsample
// Il2CppName: get_blurDownsample
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<int (Sigtrap::VrTunnellingPro::TunnellingPreset::*)()>(&Sigtrap::VrTunnellingPro::TunnellingPreset::get_blurDownsample)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(Sigtrap::VrTunnellingPro::TunnellingPreset*), "get_blurDownsample", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: Sigtrap::VrTunnellingPro::TunnellingPreset::get_overrideBlurDownsample
// Il2CppName: get_overrideBlurDownsample
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<bool (Sigtrap::VrTunnellingPro::TunnellingPreset::*)()>(&Sigtrap::VrTunnellingPro::TunnellingPreset::get_overrideBlurDownsample)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(Sigtrap::VrTunnellingPro::TunnellingPreset*), "get_overrideBlurDownsample", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: Sigtrap::VrTunnellingPro::TunnellingPreset::get_blurDistance
// Il2CppName: get_blurDistance
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<float (Sigtrap::VrTunnellingPro::TunnellingPreset::*)()>(&Sigtrap::VrTunnellingPro::TunnellingPreset::get_blurDistance)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(Sigtrap::VrTunnellingPro::TunnellingPreset*), "get_blurDistance", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: Sigtrap::VrTunnellingPro::TunnellingPreset::get_overrideBlurDistance
// Il2CppName: get_overrideBlurDistance
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<bool (Sigtrap::VrTunnellingPro::TunnellingPreset::*)()>(&Sigtrap::VrTunnellingPro::TunnellingPreset::get_overrideBlurDistance)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(Sigtrap::VrTunnellingPro::TunnellingPreset*), "get_overrideBlurDistance", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: Sigtrap::VrTunnellingPro::TunnellingPreset::get_blurPasses
// Il2CppName: get_blurPasses
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<int (Sigtrap::VrTunnellingPro::TunnellingPreset::*)()>(&Sigtrap::VrTunnellingPro::TunnellingPreset::get_blurPasses)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(Sigtrap::VrTunnellingPro::TunnellingPreset*), "get_blurPasses", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: Sigtrap::VrTunnellingPro::TunnellingPreset::get_overrideBlurPasses
// Il2CppName: get_overrideBlurPasses
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<bool (Sigtrap::VrTunnellingPro::TunnellingPreset::*)()>(&Sigtrap::VrTunnellingPro::TunnellingPreset::get_overrideBlurPasses)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(Sigtrap::VrTunnellingPro::TunnellingPreset*), "get_overrideBlurPasses", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: Sigtrap::VrTunnellingPro::TunnellingPreset::get_blurSamples
// Il2CppName: get_blurSamples
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<::Sigtrap::VrTunnellingPro::TunnellingImageBase::BlurKernel (Sigtrap::VrTunnellingPro::TunnellingPreset::*)()>(&Sigtrap::VrTunnellingPro::TunnellingPreset::get_blurSamples)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(Sigtrap::VrTunnellingPro::TunnellingPreset*), "get_blurSamples", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: Sigtrap::VrTunnellingPro::TunnellingPreset::get_overrideBlurSamples
// Il2CppName: get_overrideBlurSamples
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<bool (Sigtrap::VrTunnellingPro::TunnellingPreset::*)()>(&Sigtrap::VrTunnellingPro::TunnellingPreset::get_overrideBlurSamples)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(Sigtrap::VrTunnellingPro::TunnellingPreset*), "get_overrideBlurSamples", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: Sigtrap::VrTunnellingPro::TunnellingPreset::get_counterVelocityMode
// Il2CppName: get_counterVelocityMode
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<::Sigtrap::VrTunnellingPro::TunnellingImageBase::CounterVelocityMode (Sigtrap::VrTunnellingPro::TunnellingPreset::*)()>(&Sigtrap::VrTunnellingPro::TunnellingPreset::get_counterVelocityMode)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(Sigtrap::VrTunnellingPro::TunnellingPreset*), "get_counterVelocityMode", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: Sigtrap::VrTunnellingPro::TunnellingPreset::get_overrideCounterVelocityMode
// Il2CppName: get_overrideCounterVelocityMode
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<bool (Sigtrap::VrTunnellingPro::TunnellingPreset::*)()>(&Sigtrap::VrTunnellingPro::TunnellingPreset::get_overrideCounterVelocityMode)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(Sigtrap::VrTunnellingPro::TunnellingPreset*), "get_overrideCounterVelocityMode", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: Sigtrap::VrTunnellingPro::TunnellingPreset::get_counterVelocityResetDistance
// Il2CppName: get_counterVelocityResetDistance
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<float (Sigtrap::VrTunnellingPro::TunnellingPreset::*)()>(&Sigtrap::VrTunnellingPro::TunnellingPreset::get_counterVelocityResetDistance)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(Sigtrap::VrTunnellingPro::TunnellingPreset*), "get_counterVelocityResetDistance", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: Sigtrap::VrTunnellingPro::TunnellingPreset::get_overrideCounterVelocityResetDistance
// Il2CppName: get_overrideCounterVelocityResetDistance
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<bool (Sigtrap::VrTunnellingPro::TunnellingPreset::*)()>(&Sigtrap::VrTunnellingPro::TunnellingPreset::get_overrideCounterVelocityResetDistance)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(Sigtrap::VrTunnellingPro::TunnellingPreset*), "get_overrideCounterVelocityResetDistance", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: Sigtrap::VrTunnellingPro::TunnellingPreset::get_counterVelocityResetTime
// Il2CppName: get_counterVelocityResetTime
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<float (Sigtrap::VrTunnellingPro::TunnellingPreset::*)()>(&Sigtrap::VrTunnellingPro::TunnellingPreset::get_counterVelocityResetTime)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(Sigtrap::VrTunnellingPro::TunnellingPreset*), "get_counterVelocityResetTime", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: Sigtrap::VrTunnellingPro::TunnellingPreset::get_overrideCounterVelocityResetTime
// Il2CppName: get_overrideCounterVelocityResetTime
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<bool (Sigtrap::VrTunnellingPro::TunnellingPreset::*)()>(&Sigtrap::VrTunnellingPro::TunnellingPreset::get_overrideCounterVelocityResetTime)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(Sigtrap::VrTunnellingPro::TunnellingPreset*), "get_overrideCounterVelocityResetTime", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: Sigtrap::VrTunnellingPro::TunnellingPreset::get_counterVelocityStrength
// Il2CppName: get_counterVelocityStrength
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<float (Sigtrap::VrTunnellingPro::TunnellingPreset::*)()>(&Sigtrap::VrTunnellingPro::TunnellingPreset::get_counterVelocityStrength)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(Sigtrap::VrTunnellingPro::TunnellingPreset*), "get_counterVelocityStrength", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: Sigtrap::VrTunnellingPro::TunnellingPreset::get_overrideCounterVelocityStrength
// Il2CppName: get_overrideCounterVelocityStrength
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<bool (Sigtrap::VrTunnellingPro::TunnellingPreset::*)()>(&Sigtrap::VrTunnellingPro::TunnellingPreset::get_overrideCounterVelocityStrength)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(Sigtrap::VrTunnellingPro::TunnellingPreset*), "get_overrideCounterVelocityStrength", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: Sigtrap::VrTunnellingPro::TunnellingPreset::get_counterVelocityPerAxis
// Il2CppName: get_counterVelocityPerAxis
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<::UnityEngine::Vector3 (Sigtrap::VrTunnellingPro::TunnellingPreset::*)()>(&Sigtrap::VrTunnellingPro::TunnellingPreset::get_counterVelocityPerAxis)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(Sigtrap::VrTunnellingPro::TunnellingPreset*), "get_counterVelocityPerAxis", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: Sigtrap::VrTunnellingPro::TunnellingPreset::get_overrideCounterVelocityPerAxis
// Il2CppName: get_overrideCounterVelocityPerAxis
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<bool (Sigtrap::VrTunnellingPro::TunnellingPreset::*)()>(&Sigtrap::VrTunnellingPro::TunnellingPreset::get_overrideCounterVelocityPerAxis)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(Sigtrap::VrTunnellingPro::TunnellingPreset*), "get_overrideCounterVelocityPerAxis", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: Sigtrap::VrTunnellingPro::TunnellingPreset::get_irisZRejection
// Il2CppName: get_irisZRejection
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<bool (Sigtrap::VrTunnellingPro::TunnellingPreset::*)()>(&Sigtrap::VrTunnellingPro::TunnellingPreset::get_irisZRejection)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(Sigtrap::VrTunnellingPro::TunnellingPreset*), "get_irisZRejection", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: Sigtrap::VrTunnellingPro::TunnellingPreset::get_overrideIrisZRejection
// Il2CppName: get_overrideIrisZRejection
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<bool (Sigtrap::VrTunnellingPro::TunnellingPreset::*)()>(&Sigtrap::VrTunnellingPro::TunnellingPreset::get_overrideIrisZRejection)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(Sigtrap::VrTunnellingPro::TunnellingPreset*), "get_overrideIrisZRejection", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: Sigtrap::VrTunnellingPro::TunnellingPreset::New_ctor
// Il2CppName: .ctor
// Cannot get method pointer of value based method overload from template for constructor!
// Try using FindMethod instead!
