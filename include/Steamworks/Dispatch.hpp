// Autogenerated from CppHeaderCreator
// Created by Sc2ad
// =========================================================================
#pragma once
// Begin includes
#include "beatsaber-hook/shared/utils/typedefs.h"
#include "beatsaber-hook/shared/utils/byref.hpp"
// Including type: Steamworks.CallbackType
#include "Steamworks/CallbackType.hpp"
// Including type: Steamworks.Data.HSteamPipe
#include "Steamworks/Data/HSteamPipe.hpp"
// Including type: System.IntPtr
#include "System/IntPtr.hpp"
#include "beatsaber-hook/shared/utils/il2cpp-utils-methods.hpp"
#include "beatsaber-hook/shared/utils/il2cpp-utils-properties.hpp"
#include "beatsaber-hook/shared/utils/il2cpp-utils-fields.hpp"
#include "beatsaber-hook/shared/utils/utils.h"
#include "beatsaber-hook/shared/utils/typedefs-string.hpp"
// Completed includes
// Begin forward declares
// Forward declaring namespace: Steamworks
namespace Steamworks {
  // Forward declaring type: ICallbackData
  class ICallbackData;
}
// Forward declaring namespace: System
namespace System {
  // Forward declaring type: Action
  class Action;
  // Forward declaring type: Action`3<T1, T2, T3>
  template<typename T1, typename T2, typename T3>
  class Action_3;
  // Forward declaring type: Action`1<T>
  template<typename T>
  class Action_1;
  // Forward declaring type: Exception
  class Exception;
}
// Forward declaring namespace: System::Collections::Generic
namespace System::Collections::Generic {
  // Forward declaring type: List`1<T>
  template<typename T>
  class List_1;
  // Forward declaring type: Dictionary`2<TKey, TValue>
  template<typename TKey, typename TValue>
  class Dictionary_2;
}
// Completed forward declares
// Type namespace: Steamworks
namespace Steamworks {
  // Forward declaring type: Dispatch
  class Dispatch;
}
#include "beatsaber-hook/shared/utils/il2cpp-type-check.hpp"
NEED_NO_BOX(::Steamworks::Dispatch);
DEFINE_IL2CPP_ARG_TYPE(::Steamworks::Dispatch*, "Steamworks", "Dispatch");
// Type namespace: Steamworks
namespace Steamworks {
  // Size: 0x10
  #pragma pack(push, 1)
  // Autogenerated type: Steamworks.Dispatch
  // [TokenAttribute] Offset: FFFFFFFF
  class Dispatch : public ::Il2CppObject {
    public:
    // Nested type: ::Steamworks::Dispatch::CallbackMsg_t
    struct CallbackMsg_t;
    // Nested type: ::Steamworks::Dispatch::ResultCallback
    struct ResultCallback;
    // Nested type: ::Steamworks::Dispatch::Callback
    struct Callback;
    // Nested type: ::Steamworks::Dispatch::$$c
    class $$c;
    // Nested type: ::Steamworks::Dispatch::$LoopClientAsync$d__22
    class $LoopClientAsync$d__22;
    // Nested type: ::Steamworks::Dispatch::$$c__DisplayClass29_0_1<T>
    template<typename T>
    class $$c__DisplayClass29_0_1;
    // Size: 0x9
    #pragma pack(push, 1)
    // WARNING Layout: Sequential may not be correctly taken into account!
    // Autogenerated type: Steamworks.Dispatch/Steamworks.ResultCallback
    // [TokenAttribute] Offset: FFFFFFFF
    struct ResultCallback/*, public ::System::ValueType*/ {
      public:
      public:
      // public System.Action continuation
      // Size: 0x8
      // Offset: 0x0
      ::System::Action* continuation;
      // Field size check
      static_assert(sizeof(::System::Action*) == 0x8);
      // public System.Boolean server
      // Size: 0x1
      // Offset: 0x8
      bool server;
      // Field size check
      static_assert(sizeof(bool) == 0x1);
      public:
      // Creating value type constructor for type: ResultCallback
      constexpr ResultCallback(::System::Action* continuation_ = {}, bool server_ = {}) noexcept : continuation{continuation_}, server{server_} {}
      // Creating interface conversion operator: operator ::System::ValueType
      operator ::System::ValueType() noexcept {
        return *reinterpret_cast<::System::ValueType*>(this);
      }
      // Get instance field reference: public System.Action continuation
      ::System::Action*& dyn_continuation();
      // Get instance field reference: public System.Boolean server
      bool& dyn_server();
    }; // Steamworks.Dispatch/Steamworks.ResultCallback
    #pragma pack(pop)
    static check_size<sizeof(Dispatch::ResultCallback), 8 + sizeof(bool)> __Steamworks_Dispatch_ResultCallbackSizeCheck;
    static_assert(sizeof(Dispatch::ResultCallback) == 0x9);
    // Size: 0x9
    #pragma pack(push, 1)
    // WARNING Layout: Sequential may not be correctly taken into account!
    // Autogenerated type: Steamworks.Dispatch/Steamworks.Callback
    // [TokenAttribute] Offset: FFFFFFFF
    struct Callback/*, public ::System::ValueType*/ {
      public:
      public:
      // public System.Action`1<System.IntPtr> action
      // Size: 0x8
      // Offset: 0x0
      ::System::Action_1<::System::IntPtr>* action;
      // Field size check
      static_assert(sizeof(::System::Action_1<::System::IntPtr>*) == 0x8);
      // public System.Boolean server
      // Size: 0x1
      // Offset: 0x8
      bool server;
      // Field size check
      static_assert(sizeof(bool) == 0x1);
      public:
      // Creating value type constructor for type: Callback
      constexpr Callback(::System::Action_1<::System::IntPtr>* action_ = {}, bool server_ = {}) noexcept : action{action_}, server{server_} {}
      // Creating interface conversion operator: operator ::System::ValueType
      operator ::System::ValueType() noexcept {
        return *reinterpret_cast<::System::ValueType*>(this);
      }
      // Get instance field reference: public System.Action`1<System.IntPtr> action
      ::System::Action_1<::System::IntPtr>*& dyn_action();
      // Get instance field reference: public System.Boolean server
      bool& dyn_server();
    }; // Steamworks.Dispatch/Steamworks.Callback
    #pragma pack(pop)
    static check_size<sizeof(Dispatch::Callback), 8 + sizeof(bool)> __Steamworks_Dispatch_CallbackSizeCheck;
    static_assert(sizeof(Dispatch::Callback) == 0x9);
    // Get static field: static public System.Action`3<Steamworks.CallbackType,System.String,System.Boolean> OnDebugCallback
    static ::System::Action_3<::Steamworks::CallbackType, ::StringW, bool>* _get_OnDebugCallback();
    // Set static field: static public System.Action`3<Steamworks.CallbackType,System.String,System.Boolean> OnDebugCallback
    static void _set_OnDebugCallback(::System::Action_3<::Steamworks::CallbackType, ::StringW, bool>* value);
    // Get static field: static public System.Action`1<System.Exception> OnException
    static ::System::Action_1<::System::Exception*>* _get_OnException();
    // Set static field: static public System.Action`1<System.Exception> OnException
    static void _set_OnException(::System::Action_1<::System::Exception*>* value);
    // [DebuggerBrowsableAttribute] Offset: 0x71E134
    // Get static field: static private Steamworks.Data.HSteamPipe <ClientPipe>k__BackingField
    static ::Steamworks::Data::HSteamPipe _get_$ClientPipe$k__BackingField();
    // Set static field: static private Steamworks.Data.HSteamPipe <ClientPipe>k__BackingField
    static void _set_$ClientPipe$k__BackingField(::Steamworks::Data::HSteamPipe value);
    // [DebuggerBrowsableAttribute] Offset: 0x71E170
    // Get static field: static private Steamworks.Data.HSteamPipe <ServerPipe>k__BackingField
    static ::Steamworks::Data::HSteamPipe _get_$ServerPipe$k__BackingField();
    // Set static field: static private Steamworks.Data.HSteamPipe <ServerPipe>k__BackingField
    static void _set_$ServerPipe$k__BackingField(::Steamworks::Data::HSteamPipe value);
    // Get static field: static private System.Boolean runningFrame
    static bool _get_runningFrame();
    // Set static field: static private System.Boolean runningFrame
    static void _set_runningFrame(bool value);
    // Get static field: static private System.Collections.Generic.List`1<System.Action`1<System.IntPtr>> actionsToCall
    static ::System::Collections::Generic::List_1<::System::Action_1<::System::IntPtr>*>* _get_actionsToCall();
    // Set static field: static private System.Collections.Generic.List`1<System.Action`1<System.IntPtr>> actionsToCall
    static void _set_actionsToCall(::System::Collections::Generic::List_1<::System::Action_1<::System::IntPtr>*>* value);
    // Get static field: static private System.Collections.Generic.Dictionary`2<System.UInt64,Steamworks.Dispatch/Steamworks.ResultCallback> ResultCallbacks
    static ::System::Collections::Generic::Dictionary_2<uint64_t, ::Steamworks::Dispatch::ResultCallback>* _get_ResultCallbacks();
    // Set static field: static private System.Collections.Generic.Dictionary`2<System.UInt64,Steamworks.Dispatch/Steamworks.ResultCallback> ResultCallbacks
    static void _set_ResultCallbacks(::System::Collections::Generic::Dictionary_2<uint64_t, ::Steamworks::Dispatch::ResultCallback>* value);
    // Get static field: static private System.Collections.Generic.Dictionary`2<Steamworks.CallbackType,System.Collections.Generic.List`1<Steamworks.Dispatch/Steamworks.Callback>> Callbacks
    static ::System::Collections::Generic::Dictionary_2<::Steamworks::CallbackType, ::System::Collections::Generic::List_1<::Steamworks::Dispatch::Callback>*>* _get_Callbacks();
    // Set static field: static private System.Collections.Generic.Dictionary`2<Steamworks.CallbackType,System.Collections.Generic.List`1<Steamworks.Dispatch/Steamworks.Callback>> Callbacks
    static void _set_Callbacks(::System::Collections::Generic::Dictionary_2<::Steamworks::CallbackType, ::System::Collections::Generic::List_1<::Steamworks::Dispatch::Callback>*>* value);
    // static Steamworks.Data.HSteamPipe get_ClientPipe()
    // Offset: 0xA5B8F8
    static ::Steamworks::Data::HSteamPipe get_ClientPipe();
    // static System.Void set_ClientPipe(Steamworks.Data.HSteamPipe value)
    // Offset: 0xA5B960
    static void set_ClientPipe(::Steamworks::Data::HSteamPipe value);
    // static Steamworks.Data.HSteamPipe get_ServerPipe()
    // Offset: 0xA5B9CC
    static ::Steamworks::Data::HSteamPipe get_ServerPipe();
    // static private System.Void .cctor()
    // Offset: 0xA5CCD0
    static void _cctor();
    // static System.Void SteamAPI_ManualDispatch_Init()
    // Offset: 0xA5B6E8
    static void SteamAPI_ManualDispatch_Init();
    // static System.Void SteamAPI_ManualDispatch_RunFrame(Steamworks.Data.HSteamPipe pipe)
    // Offset: 0xA5B758
    static void SteamAPI_ManualDispatch_RunFrame(::Steamworks::Data::HSteamPipe pipe);
    // static System.Boolean SteamAPI_ManualDispatch_GetNextCallback(Steamworks.Data.HSteamPipe pipe, in Steamworks.Dispatch/Steamworks.CallbackMsg_t msg)
    // Offset: 0xA5B7D8
    static bool SteamAPI_ManualDispatch_GetNextCallback(::Steamworks::Data::HSteamPipe pipe, ByRef<::Steamworks::Dispatch::CallbackMsg_t> msg);
    // static System.Boolean SteamAPI_ManualDispatch_FreeLastCallback(Steamworks.Data.HSteamPipe pipe)
    // Offset: 0xA5B870
    static bool SteamAPI_ManualDispatch_FreeLastCallback(::Steamworks::Data::HSteamPipe pipe);
    // static System.Void Init()
    // Offset: 0xA5BA34
    static void Init();
    // static System.Void Frame(Steamworks.Data.HSteamPipe pipe)
    // Offset: 0xA5BA90
    static void Frame(::Steamworks::Data::HSteamPipe pipe);
    // static private System.Void ProcessCallback(Steamworks.Dispatch/Steamworks.CallbackMsg_t msg, System.Boolean isServer)
    // Offset: 0xA5BEC4
    static void ProcessCallback(::Steamworks::Dispatch::CallbackMsg_t msg, bool isServer);
    // static System.String CallbackToString(Steamworks.CallbackType type, System.IntPtr data, System.Int32 expectedsize)
    // Offset: 0xA5C278
    static ::StringW CallbackToString(::Steamworks::CallbackType type, ::System::IntPtr data, int expectedsize);
    // static private System.Void ProcessResult(Steamworks.Dispatch/Steamworks.CallbackMsg_t msg)
    // Offset: 0xA5C5CC
    static void ProcessResult(::Steamworks::Dispatch::CallbackMsg_t msg);
    // static System.Void LoopClientAsync()
    // Offset: 0xA5C74C
    static void LoopClientAsync();
    // static System.Void Install(System.Action`1<T> p, System.Boolean server)
    // Offset: 0xFFFFFFFF
    template<class T>
    static void Install(::System::Action_1<T>* p, bool server) {
      static_assert(std::is_convertible_v<std::remove_pointer_t<T>, ::Steamworks::ICallbackData>);
      static auto ___internal__logger = ::Logger::get().WithContext("::Steamworks::Dispatch::Install");
      static auto* ___internal__method = THROW_UNLESS((::il2cpp_utils::FindMethod("Steamworks", "Dispatch", "Install", std::vector<Il2CppClass*>{::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<T>::get()}, ::std::vector<const Il2CppType*>{::il2cpp_utils::ExtractType(p), ::il2cpp_utils::ExtractType(server)})));
      static auto* ___generic__method = THROW_UNLESS(::il2cpp_utils::MakeGenericMethod(___internal__method, std::vector<Il2CppClass*>{::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<T>::get()}));
      ::il2cpp_utils::RunMethodRethrow<void, false>(static_cast<Il2CppObject*>(nullptr), ___generic__method, p, server);
    }
    // static System.Void ShutdownClient()
    // Offset: 0xA5C7FC
    static void ShutdownClient();
  }; // Steamworks.Dispatch
  #pragma pack(pop)
}
#include "beatsaber-hook/shared/utils/il2cpp-type-check.hpp"
DEFINE_IL2CPP_ARG_TYPE(::Steamworks::Dispatch::Callback, "Steamworks", "Dispatch/Callback");
#include "beatsaber-hook/shared/utils/il2cpp-type-check.hpp"
DEFINE_IL2CPP_ARG_TYPE(::Steamworks::Dispatch::ResultCallback, "Steamworks", "Dispatch/ResultCallback");
#include "beatsaber-hook/shared/utils/il2cpp-utils-methods.hpp"
// Writing MetadataGetter for method: Steamworks::Dispatch::get_ClientPipe
// Il2CppName: get_ClientPipe
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<::Steamworks::Data::HSteamPipe (*)()>(&Steamworks::Dispatch::get_ClientPipe)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(Steamworks::Dispatch*), "get_ClientPipe", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: Steamworks::Dispatch::set_ClientPipe
// Il2CppName: set_ClientPipe
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (*)(::Steamworks::Data::HSteamPipe)>(&Steamworks::Dispatch::set_ClientPipe)> {
  static const MethodInfo* get() {
    static auto* value = &::il2cpp_utils::GetClassFromName("Steamworks.Data", "HSteamPipe")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(Steamworks::Dispatch*), "set_ClientPipe", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{value});
  }
};
// Writing MetadataGetter for method: Steamworks::Dispatch::get_ServerPipe
// Il2CppName: get_ServerPipe
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<::Steamworks::Data::HSteamPipe (*)()>(&Steamworks::Dispatch::get_ServerPipe)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(Steamworks::Dispatch*), "get_ServerPipe", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: Steamworks::Dispatch::_cctor
// Il2CppName: .cctor
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (*)()>(&Steamworks::Dispatch::_cctor)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(Steamworks::Dispatch*), ".cctor", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: Steamworks::Dispatch::SteamAPI_ManualDispatch_Init
// Il2CppName: SteamAPI_ManualDispatch_Init
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (*)()>(&Steamworks::Dispatch::SteamAPI_ManualDispatch_Init)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(Steamworks::Dispatch*), "SteamAPI_ManualDispatch_Init", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: Steamworks::Dispatch::SteamAPI_ManualDispatch_RunFrame
// Il2CppName: SteamAPI_ManualDispatch_RunFrame
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (*)(::Steamworks::Data::HSteamPipe)>(&Steamworks::Dispatch::SteamAPI_ManualDispatch_RunFrame)> {
  static const MethodInfo* get() {
    static auto* pipe = &::il2cpp_utils::GetClassFromName("Steamworks.Data", "HSteamPipe")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(Steamworks::Dispatch*), "SteamAPI_ManualDispatch_RunFrame", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{pipe});
  }
};
// Writing MetadataGetter for method: Steamworks::Dispatch::SteamAPI_ManualDispatch_GetNextCallback
// Il2CppName: SteamAPI_ManualDispatch_GetNextCallback
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<bool (*)(::Steamworks::Data::HSteamPipe, ByRef<::Steamworks::Dispatch::CallbackMsg_t>)>(&Steamworks::Dispatch::SteamAPI_ManualDispatch_GetNextCallback)> {
  static const MethodInfo* get() {
    static auto* pipe = &::il2cpp_utils::GetClassFromName("Steamworks.Data", "HSteamPipe")->byval_arg;
    static auto* msg = &::il2cpp_utils::GetClassFromName("Steamworks", "Dispatch/CallbackMsg_t")->this_arg;
    return ::il2cpp_utils::FindMethod(classof(Steamworks::Dispatch*), "SteamAPI_ManualDispatch_GetNextCallback", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{pipe, msg});
  }
};
// Writing MetadataGetter for method: Steamworks::Dispatch::SteamAPI_ManualDispatch_FreeLastCallback
// Il2CppName: SteamAPI_ManualDispatch_FreeLastCallback
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<bool (*)(::Steamworks::Data::HSteamPipe)>(&Steamworks::Dispatch::SteamAPI_ManualDispatch_FreeLastCallback)> {
  static const MethodInfo* get() {
    static auto* pipe = &::il2cpp_utils::GetClassFromName("Steamworks.Data", "HSteamPipe")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(Steamworks::Dispatch*), "SteamAPI_ManualDispatch_FreeLastCallback", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{pipe});
  }
};
// Writing MetadataGetter for method: Steamworks::Dispatch::Init
// Il2CppName: Init
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (*)()>(&Steamworks::Dispatch::Init)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(Steamworks::Dispatch*), "Init", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: Steamworks::Dispatch::Frame
// Il2CppName: Frame
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (*)(::Steamworks::Data::HSteamPipe)>(&Steamworks::Dispatch::Frame)> {
  static const MethodInfo* get() {
    static auto* pipe = &::il2cpp_utils::GetClassFromName("Steamworks.Data", "HSteamPipe")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(Steamworks::Dispatch*), "Frame", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{pipe});
  }
};
// Writing MetadataGetter for method: Steamworks::Dispatch::ProcessCallback
// Il2CppName: ProcessCallback
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (*)(::Steamworks::Dispatch::CallbackMsg_t, bool)>(&Steamworks::Dispatch::ProcessCallback)> {
  static const MethodInfo* get() {
    static auto* msg = &::il2cpp_utils::GetClassFromName("Steamworks", "Dispatch/CallbackMsg_t")->byval_arg;
    static auto* isServer = &::il2cpp_utils::GetClassFromName("System", "Boolean")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(Steamworks::Dispatch*), "ProcessCallback", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{msg, isServer});
  }
};
// Writing MetadataGetter for method: Steamworks::Dispatch::CallbackToString
// Il2CppName: CallbackToString
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<::StringW (*)(::Steamworks::CallbackType, ::System::IntPtr, int)>(&Steamworks::Dispatch::CallbackToString)> {
  static const MethodInfo* get() {
    static auto* type = &::il2cpp_utils::GetClassFromName("Steamworks", "CallbackType")->byval_arg;
    static auto* data = &::il2cpp_utils::GetClassFromName("System", "IntPtr")->byval_arg;
    static auto* expectedsize = &::il2cpp_utils::GetClassFromName("System", "Int32")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(Steamworks::Dispatch*), "CallbackToString", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{type, data, expectedsize});
  }
};
// Writing MetadataGetter for method: Steamworks::Dispatch::ProcessResult
// Il2CppName: ProcessResult
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (*)(::Steamworks::Dispatch::CallbackMsg_t)>(&Steamworks::Dispatch::ProcessResult)> {
  static const MethodInfo* get() {
    static auto* msg = &::il2cpp_utils::GetClassFromName("Steamworks", "Dispatch/CallbackMsg_t")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(Steamworks::Dispatch*), "ProcessResult", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{msg});
  }
};
// Writing MetadataGetter for method: Steamworks::Dispatch::LoopClientAsync
// Il2CppName: LoopClientAsync
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (*)()>(&Steamworks::Dispatch::LoopClientAsync)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(Steamworks::Dispatch*), "LoopClientAsync", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: Steamworks::Dispatch::Install
// Il2CppName: Install
// Cannot write MetadataGetter for generic methods!
// Writing MetadataGetter for method: Steamworks::Dispatch::ShutdownClient
// Il2CppName: ShutdownClient
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (*)()>(&Steamworks::Dispatch::ShutdownClient)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(Steamworks::Dispatch*), "ShutdownClient", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
